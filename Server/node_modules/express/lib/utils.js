/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict';

/**
 * Module dependencies.
 * @api private
 */

// The 'Buffer' module is required for handling buffers.
const Buffer = require('safe-buffer').Buffer;

// The 'content-disposition' module is required for generating the
// Content-Disposition header for file downloads.
const contentDisposition = require('content-disposition');

// The 'content-type' module is required for handling content types.
const contentType = require('content-type');

// The 'depd' module is used for deprecating certain functions.
const deprecate = require('depd')('express');

// The 'array-flatten' module is required for flattening arrays.
const flatten = require('array-flatten');

// The 'send' module is required for handling file uploads.
const mime = require('send').mime;

// The 'etag' module is required for generating ETags for caching.
const etag = require('etag');

// The 'proxy-addr' module is required for determining the IP address of
// the client when using a proxy server.
const proxyaddr = require('proxy-addr');

// The 'qs' module is required for parsing query strings.
const qs = require('qs');

// The 'querystring' module is a built-in Node.js module for parsing query strings.
const querystring = require('querystring');

/**
 * Return strong ETag for `body`.
 *
 * @param {String|Buffer} body - The body of the response.
 * @param {String} [encoding] - The encoding of the body.
 * @return {String} - The strong ETag for the body.
 * @api private
 */

// The 'exports.etag' function generates a strong ETag for the given body.
exports.etag = createETagGenerator({ weak: false });

/**
 * Return weak ETag for `body`.
 *
 * @param {String|Buffer} body - The body of the response.
 * @param {String} [encoding] - The encoding of the body.
 * @return {String} - The weak ETag for the body.
 * @api private
 */

// The 'exports.wetag' function generates a weak ETag for the given body.
exports.wetag = createETagGenerator({ weak: true });

/**
 * Check if `path` looks absolute.
 *
 * @param {String} path - The path to check.
 * @return {Boolean} - True if the path is absolute, false otherwise.
 * @api private
 */

// The 'exports.isAbsolute' function checks if the given path is absolute.
exports.isAbsolute = function(path){
  // If the path starts with a '/', it is absolute.
  if ('/' === path[0]) return true;
  // If the path starts with a ':' and the second character is a '\' or '/',
  // it is an absolute Windows device path.
  if (':' === path[1] && ('\\' === path[2] || '/' === path[2])) return true;
  // If the path starts with '\\\\', it is an absolute Microsoft Azure path.
  if ('\\\\' === path.substring(0, 2)) return true;
};

/**
 * Flatten the given `arr`.
 *
 * @param {Array} arr - The array to flatten.
 * @return {Array} - The flattened array.
 * @api private
 */

// The 'exports.flatten' function flattens the given array.
exports.flatten = deprecate.function(flatten,
  'utils.flatten: use array-flatten npm module instead');

/**
 * Normalize the given `type`, for example "html" becomes "text/html".
 *
 * @param {String} type - The content type to normalize.
 * @return {Object} - The normalized content type.
 * @api private
 */

// The 'exports.normalizeType' function normalizes the given content type.
exports.normalizeType = function(type){
  // If the content type already contains '/', it is already normalized.
  return ~type.indexOf('/')
    // If the content type is not normalized, parse it and add default parameters.
    ? acceptParams(type)
    // Return the normalized content type.
    : { value: mime.lookup(type), params: {} };
};

/**
 * Normalize `types`, for example "html" becomes "text/html".
 *
 * @param {Array} types - The array of content types to normalize.
 * @return {Array} - The normalized array of content types.
 * @api private
 */

// The 'exports.normalizeTypes' function normalizes the given array of content types.
exports.normalizeTypes = function(types){
  // Create a new array to store the normalized content types.
  const ret = [];

  // Loop through the given array of content types.
  for (let i = 0; i < types.length; ++i) {
    // Normalize each content type and add it to the new array.
    ret.push(exports.normalizeType(types[i]));
  }

  // Return the normalized array of content types.
  return ret;
};

/**
 * Generate Content-Disposition header appropriate for the filename.
 * non-ascii filenames are urlencoded and a filename* parameter is added
 *
 * @param {String} filename - The filename to generate the header for.
 * @return {String} - The generated Content-Disposition header.
 * @api private
 */

// The 'exports.contentDisposition' function generates a Content-Disposition header for the given filename.
exports.contentDisposition = deprecate.function(contentDisposition,
  'utils.contentDisposition: use content-disposition npm module instead');

/**
 * Parse accept params `str` returning an
 * object with `.value`, `.quality` and `.params`.
 * also includes `.originalIndex` for stable sorting
 *
 * @param
