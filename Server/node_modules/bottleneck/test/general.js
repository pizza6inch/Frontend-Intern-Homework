var makeTest = require('./context') // Import the makeTest function from the context module
var Bottleneck = require('./bottleneck') // Import the Bottleneck module
var assert = require('assert') // Import the assert module for assertions
var child_process = require('child_process') // Import the child_process module for spawning processes

describe('General', function () { // Begin describing the general functionality
  var c; // Declare the c variable to hold the test context

  // After each test, disconnect the limiter
  afterEach(function () {
    return c.limiter.disconnect(false)
  })

  // Check if the code does not leak memory on instantiation
  if (
    process.env.DATASTORE !== 'redis' && process.env.DATASTORE !== 'ioredis' &&
    process.env.BUILD !== 'es5' && process.env.BUILD !== 'light'
  ) {
    it('Should not leak memory on instantiation', async function () {
      c = makeTest() // Create a new test context
      this.timeout(8000) // Set the test timeout to 8000ms
      const { iterate } = require('leakage') // Import the iterate function from the leakage module

      const result = await iterate.async(async () => {
        const limiter = new Bottleneck({ datastore: 'local' }) // Create a new limiter with the local datastore
        await limiter.ready() // Wait for the limiter to be ready
        return limiter.disconnect(false) // Disconnect the limiter without releasing resources
      }, { iterations: 25 }) // Run the test 25 times
    })
  }

  // Check if the code does not leak memory running jobs
  it('Should not leak memory running jobs', async function () {
    c = makeTest() // Create a new test context
    this.timeout(12000) // Set the test timeout to 12000ms
    const { iterate } = require('leakage') // Import the iterate function from the leakage module
    const limiter = new Bottleneck({ datastore: 'local', maxConcurrent: 1, minTime: 10 }) // Create a new limiter with the local datastore, maxConcurrent set to 1, and minTime set to 10
    await limiter.ready() // Wait for the limiter to be ready
    var ctr = 0
    var i = 0

    const result = await iterate.async(async () => {
      await limiter.schedule(function (zero, one) {
        i = i + zero + one
      }, 0, 1)
      await limiter.schedule(function (zero, one) {
        i = i + zero + one
      }, 0, 1)
    }, { iterations: 25 })
    c.mustEqual(i, 302) // Check if the i variable has the expected value
  })
})

// ... Rest of the code ...
