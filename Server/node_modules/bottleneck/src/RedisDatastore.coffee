// Import required modules
const parser = require("./parser");
const BottleneckError = require("./BottleneckError");
const RedisConnection = require("./RedisConnection");
const IORedisConnection = require("./IORedisConnection");

// Define the RedisDatastore class
class RedisDatastore {
  // Constructor function
  constructor(instance, storeOptions, storeInstanceOptions) {
    // Initialize properties
    this.originalId = instance.id;
    this.clientId = instance._randomIndex();
    parser.load(storeInstanceOptions, storeInstanceOptions, this);
    this.clients = {};
    this.capacityPriorityCounters = {};
    this.sharedConnection = this.connection;

    // Initialize the connection
    this.connection =
      instance.datastore === "redis"
        ? new RedisConnection({
            Redis: this.Redis,
            clientOptions: this.clientOptions,
            Promise: this.Promise,
            Events: instance.Events,
          })
        : new IORedisConnection({
            Redis: this.Redis,
            clientOptions: this.clientOptions,
            clusterNodes: this.clusterNodes,
            Promise: this.Promise,
            Events: instance.Events,
          });

    // Set the connection and datastore properties on the instance
    instance.connection = this.connection;
    instance.datastore = this.connection.datastore;

    // Initialize the ready property
    this.ready = this.connection.ready
      .then((clients) => this.runScript("init", this.prepareInitSettings(false)))
      .then(() => this.connection.__addLimiter__(instance))
      .then(() => this.runScript("register_client", [instance.queued()]))
      .then(() => {
        this.heartbeat = setInterval(() => {
          this.runScript("heartbeat", []);
        }, this.heartbeatInterval);
        return this.clients;
      })
      .catch((e) => {
        instance.Events.trigger("error", e);
      });
  }

  // Publish a message
  __publish__(message) {
    this.ready.then(({ client }) => {
      client.publish(instance.channel(), `message:${message.toString()}`);
    });
  }

  // Handle incoming messages
  onMessage(channel, message) {
    try {
      const pos = message.indexOf(":");
      const type = message.slice(0, pos);
      const data = message.slice(pos + 1);

      if (type === "capacity") {
        this.__drainAll__(data.length > 0 ? parseInt(data) : null);
      } else if (type === "capacity-priority") {
        const [rawCapacity, priorityClient, counter] = data.split(":");
        const capacity = rawCapacity.length > 0 ? parseInt(rawCapacity) : null;

        if (priorityClient === this.clientId) {
          this.__drainAll__(capacity).then((drained) => {
            const newCapacity = capacity ? capacity - (drained || 0) : "";
            this.clients.client.publish(instance.channel(), `capacity-priority:${newCapacity}::${counter}`);
          });
        } else if (priorityClient === "") {
          clearTimeout(this.capacityPriorityCounters[counter]);
          delete this.capacityPriorityCounters[counter];
          this.__drainAll__(capacity);
        } else {
          this.capacityPriorityCounters[counter] = setTimeout(() => {
            delete this.capacityPriorityCounters[counter];
            this.runScript("blacklist_client", [priorityClient]).catch((e) =>
              instance.Events.trigger("error", e)
            );
            this.__drainAll__(capacity);
          }, 1000);
        }
      } else if (type === "message") {
        instance.Events.trigger("message", data);
      } else if (type === "blocked") {
        this.__dropAllQueued__();
      }
    } catch (e) {
      instance.Events.trigger("error", e);
    }
  }

  // Disconnect
  __disconnect__(flush) {
    clearInterval(this.heartbeat);
    if (this.sharedConnection) {
      this.connection.__removeLimiter__(instance);
    } else {
      this.connection.disconnect(flush);
    }
  }

  // Run a script
  runScript(name, args) {
    return new this.Promise((resolve, reject) => {
      const all_args = [Date.now(), this.clientId].concat(args);
      instance.Events.trigger("debug", `Calling Redis script: ${name}.lua}`, all_args);
      const arr = this.connection.__scriptArgs__(name, this.originalId, all_args, (err, replies) => {
        if (err) {
          return reject(err);
        }
        return resolve(replies);
      });
      this.connection.__scriptFn__(name)(arr);
    }).catch((e) => {
      if (e.message === "SETTINGS_KEY_NOT_FOUND") {
        if (name === "heartbeat") {
          return this.Promise.resolve();
        }
        return this.runScript("init", this.prepareInitSettings(false)).then(() =>
          this.runScript(name, args)
        );
      } else if (e.message === "UNKNOWN_CLIENT") {
        return this.runScript("register_client", [instance.queued()]).then(() =>
          this.runScript(name, args)
        );
      } else {
        return this.Promise.reject(e);
      }
    });
  }

  // Prepare an array for the script
  prepareArray(arr) {
    return arr.map((x) => (x ? x.toString() : ""));
  }

  // Prepare an object for the script
  prepareObject(obj) {
    const arr = [];
    for (const k in obj) {
      arr.push(k, obj[k] ? obj[k].toString() : "");
    }
