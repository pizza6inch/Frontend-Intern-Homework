/// <reference lib="es2018.asynciterable" />

/**
 * The `AbortSignal` interface is used for controlling the state of an asynchronous operation.
 * It is compatible with the `AbortSignal` interface defined in TypeScript's DOM types.
 * This redefinition allows for polyfilling the `AbortSignal` in a Node environment.
 *
 * @public
 */
export declare interface AbortSignal {
    // Indicates whether the request has been aborted.
    readonly aborted: boolean;

    // Returns the reason for aborting the request, if available.
    readonly reason?: any;

    // Adds an event listener to be triggered when the signal is aborted.
    addEventListener(type: 'abort', listener: () => void): void;

    // Removes an event listener previously added with `addEventListener`.
    removeEventListener(type: 'abort', listener: () => void): void;
}

/**
 * The `ByteLengthQueuingStrategy` class is a queuing strategy that counts the number of bytes in each chunk.
 * It is used for controlling the size of the internal queue of a readable stream.
 *
 * @public
 */
export declare class ByteLengthQueuingStrategy implements QueuingStrategy<ArrayBufferView> {
    // Constructs a new `ByteLengthQueuingStrategy` instance with the given options.
    constructor(options: QueuingStrategyInit);

    // Returns the high water mark provided to the constructor.
    get highWaterMark(): number;

    // Returns the size of the given chunk by returning the value of its `byteLength` property.
    get size(): (chunk: ArrayBufferView) => number;
}

/**
 * The `CountQueuingStrategy` class is a queuing strategy that counts the number of chunks.
 * It is used for controlling the size of the internal queue of a readable stream.
 *
 * @public
 */
export declare class CountQueuingStrategy implements QueuingStrategy<any> {
    // Constructs a new `CountQueuingStrategy` instance with the given options.
    constructor(options: QueuingStrategyInit);

    // Returns the high water mark provided to the constructor.
    get highWaterMark(): number;

    // Returns the size of the given chunk by always returning 1.
    // This ensures that the total queue size is a count of the number of chunks in the queue.
    get size(): (chunk: any) => 1;
}

/**
 * The `QueuingStrategy` interface defines the behavior of a queuing strategy used by a readable stream.
 * It controls the size of the internal queue of a readable stream.
 *
 * @public
 */
export declare interface QueuingStrategy<T = any> {
    // The high water mark of the stream using this queuing strategy.
    highWaterMark?: number;

    // A function that computes and returns the finite non-negative size of the given chunk value.
    size?: QueuingStrategySizeCallback<T>;
}

/**
 * The `QueuingStrategyInit` interface provides the options for creating a new `QueuingStrategy` instance.
 *
 * @public
 */
export declare interface QueuingStrategyInit {
    // The high water mark of the stream using this queuing strategy.
    highWaterMark: number;
}

/**
 * The `QueuingStrategySizeCallback` type defines a function that computes and returns the finite non-negative size of the given chunk value.
 *
 * @public
 */
export declare type QueuingStrategySizeCallback<T = any> = (chunk: T) => number;

/**
 * The `ReadableByteStreamController` class allows control of a readable byte stream's state and internal queue.
 * It is used by the `ReadableStream` class to manage the reading process.
 *
 * @internal
 */
export declare class ReadableByteStreamController {
    // Returns the current BYOB pull request, or `null` if there isn't one.
    get byobRequest(): ReadableStreamBYOBRequest | null;

    // Returns the desired size to fill the controlled stream's internal queue.
    get desiredSize(): number | null;

    // Closes the controlled readable stream.
    close(): void;

    // Enqueues the given chunk in the controlled readable stream.
    enqueue(chunk: ArrayBufferView): void;

    // Errors the controlled readable stream with the given error.
    error(e?: any): void;
}

/**
 * The `ReadableStream` class represents a readable stream of data.
 * It is used to read data asynchronously, chunk by chunk.
 *
 * @public
 */
export declare class ReadableStream<R = any> implements AsyncIterable<R> {
    // Constructs a new `ReadableStream` instance with the given underlying source and strategy.
    constructor(underlyingSource: UnderlyingByteSource, strategy?: {
        highWaterMark?: number;
        size?: undefined;
    });
    constructor(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>);

    // Indicates whether the readable stream is locked to a reader.
    get locked(): boolean;

    // Cancels the stream with the given reason.
    cancel(reason?: any): Promise<void>;

    // Creates a `ReadableStreamBYOBReader` and locks the stream to the new reader.
    getReader({ mode }: {
        mode: 'byob';
    }): ReadableStreamBYOBReader;

    // Creates a `ReadableStreamDefaultReader` and locks the stream to the new reader.
    getReader(): ReadableStreamDefaultReader<R>;

    // Pipes the readable stream to the given writable stream.
    pipeThrough<RS extends ReadableStream>(transform: {
        readable: RS;
        writable: WritableStream<R>;
    }, options?: StreamPipeOptions): RS;

    // Pipes the readable stream to the given writable stream with the given options.
    pipeTo(destination: WritableStream<R>, options?: StreamPipeOptions): Promise<void>;

    // Tees the readable stream into two branches.
    tee(): [ReadableStream<R>, ReadableStream<R>];

    // Returns an async iterator for the chunks in the stream.
    values(options?: ReadableStreamIteratorOptions): ReadableStreamAsyncIterator
