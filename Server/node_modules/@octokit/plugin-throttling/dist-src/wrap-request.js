// noop is a function that returns a resolved promise
const noop = () => Promise.resolve();

// wrapRequest is a function that takes state, request, and options as arguments
// and returns a promise that resolves after scheduling the doRequest function
// with the provided arguments using the retryLimiter
function wrapRequest(state, request, options) {
  return state.retryLimiter.schedule(doRequest, state, request, options);
}

// doRequest is an async function that takes state, request, and options as arguments
// and performs various operations based on the request method and URL
async function doRequest(state, request, options) {
  // Determine if the request is a write request or a read request
  const isWrite = options.method !== "GET" && options.method !== "HEAD";

  // Extract the pathname from the URL
  const { pathname } = new URL(options.url, "http://github.test");

  // Determine if the request is a search request
  const isSearch = options.method === "GET" && pathname.startsWith("/search/");

  // Determine if the request is a GraphQL request
  const isGraphQL = pathname.startsWith("/graphql");

  // Get the number of retries for the request
  const retryCount = ~~request.retryCount;

  // Define job options based on the number of retries
  const jobOptions = retryCount > 0 ? { priority: 0, weight: 0 } : {};

  // If clustering is enabled, set an expiration time for the job
  if (state.clustering) {
    jobOptions.expiration = 1e3 * 60;
  }

  // If the request is a write request or a GraphQL request, schedule a job with the write queue
  if (isWrite || isGraphQL) {
    await state.write.key(state.id).schedule(jobOptions, noop);
  }

  // If the request is a write request and the pathname triggers a notification, schedule a job with the notifications queue
  if (isWrite && state.triggersNotification(pathname)) {
    await state.notifications.key(state.id).schedule(jobOptions, noop);
  }

  // If the request is a search request, schedule a job with the search queue
  if (isSearch) {
