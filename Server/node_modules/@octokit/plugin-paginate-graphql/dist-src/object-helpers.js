import { MissingPageInfo } from "./errors";

// Check if a value is an object
const isObject = (value) => Object.prototype.toString.call(value) === "[object Object]";

// Find the path to the 'pageInfo' property in a paginated resource response data
function findPaginatedResourcePath(responseData) {
  const paginatedResourcePath = deepFindPathToProperty(
    responseData,
    "pageInfo"
  );
  if (paginatedResourcePath.length === 0) {
    throw new MissingPageInfo(responseData);
  }
  return paginatedResourcePath;
}

// Recursively search for a specific property in an object and return the path to it
const deepFindPathToProperty = (object, searchProp, path = []) => {
  for (const key of Object.keys(object)) {
    const currentPath = [...path, key];
    const currentValue = object[key];

    // Check if the current value has the desired property
    if (currentValue.hasOwnProperty(searchProp)) {
      return currentPath;
    }

    // If the current value is an object, search recursively
    if (isObject(currentValue)) {
      const result = deepFindPathToProperty(
        currentValue,
        searchProp,
        currentPath
      );
      if (result.length > 0) {
        return result;
      }
    }
  }
  return [];
};

// Retrieve a value from an object using a specified path
const get = (object, path) => {
  return path.reduce((current, nextProperty) => current[nextProperty], object);
};

// Set a value in an object using a specified path and a mutator function or a new value
const set = (object, path, mutator) => {
  const lastProperty = path[path.length - 1];
  const parentPath = [...path].slice(0, -1);
  const parent = get(object, parentPath);

  // If the mutator is a function, update the value using the function
  if (typeof mutator === "function") {
    parent[lastProperty] = mutator(parent[lastProperty]);
  } else {
    // Otherwise, set the value directly
    parent[lastProperty] = mutator;
  }
};

// Export
