declare module "safe-buffer" {
  // The Buffer class is the primary class in this module, representing a
  // mutable, growable buffer of bytes.
  export class Buffer {
    // The length property is the total number of octets in the buffer.
    length: number

    // The write method writes a string to the buffer at the specified offset,
    // with an optional length and encoding.
    write(string: string, offset?: number, length?: number, encoding?: string): number;

    // The toString method returns a string representation of the buffer,
    // with an optional encoding, start, and end position.
    toString(encoding?: string, start?: number, end?: number): string;

    // The toJSON method returns a JSON representation of the buffer.
    toJSON(): { type: 'Buffer', data: any[] };

    // The equals method compares this buffer to another buffer for equality.
    equals(otherBuffer: Buffer): boolean;

    // The compare method compares this buffer to another buffer, returning
    // a negative, zero, or positive value depending on whether this buffer
    // is less than, equal to, or greater than the other buffer.
    compare(otherBuffer: Buffer, targetStart?: number, targetEnd?: number, sourceStart?: number, sourceEnd?: number): number;

    // The copy method copies a portion of this buffer to another buffer.
    copy(targetBuffer: Buffer, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;

    // The slice method returns a new buffer that is a shallow copy of a portion of this buffer.
    slice(start?: number, end?: number): Buffer;

    // Various methods for writing and reading unsigned and signed integers
    // of different byte lengths at specific offsets in the buffer.
    writeUIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;
    writeUIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;
    writeIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;
    writeIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;
    readUIntLE(offset: number, byteLength: number, noAssert?: boolean): number;
    readUIntBE(offset: number, byteLength: number, noAssert?: boolean): number;
    readIntLE(offset: number, byteLength: number, noAssert?: boolean): number;
    readIntBE(offset: number, byteLength: number, noAssert?: boolean): number;
    readUInt8(offset: number, noAssert?: boolean): number;
    readUInt16LE(offset: number, noAssert?: boolean): number;
    readUInt16BE(offset: number, noAssert?: boolean): number;
    readUInt32LE(offset: number, noAssert?: boolean): number;
    readUInt32BE(offset: number, noAssert?: boolean): number;
    readInt8(offset: number, noAssert?: boolean): number;
    readInt16LE(offset: number, noAssert?: boolean): number;
    readInt16BE(offset: number, noAssert?: boolean): number;
    readInt32LE(offset: number, noAssert?: boolean): number;
    readInt32BE(offset: number, noAssert?: boolean): number;
    readFloatLE(offset: number, noAssert?: boolean): number;
    readFloatBE(offset: number, noAssert?: boolean): number;
    readDoubleLE(offset: number, noAssert?: boolean): number;
    readDoubleBE(offset: number, noAssert?: boolean): number;

    // Methods for swapping the byte order of 16-, 32-, and 64-bit integers
    // within the buffer.
    swap16(): Buffer;
    swap32(): Buffer;
    swap64(): Buffer;

    // Methods for writing unsigned and signed integers of different byte lengths
    // at specific offsets in the buffer.
    writeUInt8(value: number, offset: number, noAssert?: boolean): number;
    writeUInt16LE(value: number, offset: number, noAssert?: boolean): number;
    writeUInt16BE(value: number, offset: number, noAssert?: boolean): number;
    writeUInt32LE(value: number, offset: number, noAssert?: boolean): number;
    writeUInt32BE(value: number, offset: number, noAssert?: boolean): number;
    writeInt8(value: number, offset: number, noAssert?: boolean): number;
    writeInt16LE(value: number, offset: number, noAssert?: boolean): number;
    writeInt16BE(value: number, offset: number, noAssert?: boolean): number;
    writeInt32LE(value: number, offset: number, noAssert?: boolean): number;
    writeInt32BE(value: number, offset: number, noAssert?: boolean): number;
    writeFloatLE(value: number, offset: number, noAssert?: boolean): number;
    writeFloatBE(value: number, offset: number, noAssert?: boolean): number;
    writeDoubleLE(value: number, offset: number, noAssert?: boolean): number;
    writeDoubleBE(value: number, offset: number, noAssert?: boolean): number;

    // The fill method fills the buffer with a specified value, starting at
    // an optional offset and ending at an optional end position.
    fill(value: any, offset?: number, end?: number): this;

    // The indexOf method returns the index of the first occurrence of a
    // specified value in the buffer, starting at an optional offset.
    indexOf(value: string | number | Buffer, byteOffset?: number, encoding?: string): number;

    // The lastIndexOf method returns the index of the last occurrence of a
    // specified value in the buffer, starting at an optional offset.
    lastIndexOf(value: string | number | Buffer, byteOffset?: number, encoding?: string): number;

    // The includes method returns true if the buffer includes a specified value,
    // starting at an optional offset.
    includes(value: string | number | Buffer, byteOffset?: number, encoding?: string): boolean;

    // Constructors for creating
