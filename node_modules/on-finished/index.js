/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict'

/**
 * Module exports.
 * @public
 */

// The module exports an asynchronous function `onFinished` and a synchronous
// function `isFinished`.
module.exports = onFinished
module.exports.isFinished = isFinished

/**
 * Module dependencies.
 * @private
 */

// The module depends on the 'async_hooks' module (for Node.js 8 and above) and
// the 'ee-first' module.
var asyncHooks = tryRequireAsyncHooks()
var first = require('ee-first')

/**
 * Variables.
 * @private
 */

/* istanbul ignore next */
// A variable `defer` is defined to hold either the `setImmediate` function
// or a function that behaves similarly using `process.nextTick`.
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)) }

/**
 * Invoke callback when the response has finished, useful for
 * cleaning up resources afterwards.
 *
 * @param {object} msg - The message object to attach the listener to.
 * @param {function} listener - The callback function to be invoked when the
 *                              message has finished.
 * @return {object} - The original message object.
 * @public
 */

function onFinished (msg, listener) {
  if (isFinished(msg) !== false) {
    // If the message has already finished, invoke the listener immediately.
    defer(listener, null, msg)
    return msg
  }

  // Attach the listener to the message.
  attachListener(msg, wrap(listener))

  return msg
}

/**
 * Determine if message is already finished.
 *
 * @param {object} msg - The message object to check.
 * @return {boolean} - `true` if the message has already finished,
 *                     `false` if it has not, and `undefined` if the
 *                     status is unknown.
 * @public
 */

function isFinished (msg) {
  var socket = msg.socket

  if (typeof msg.finished === 'boolean') {
    // OutgoingMessage
    return Boolean(msg.finished || (socket && !socket.writable))
  }

  if (typeof msg.complete === 'boolean') {
    // IncomingMessage
    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))
  }

  // don't know
  return undefined
}

/**
 * Attach a finished listener to the message.
 *
 * @param {object} msg - The message object to attach the listener to.
 * @param {function} callback - The callback function to be invoked when the
 *                              message has finished.
 * @private
 */

function attachFinishedListener (msg, callback) {
  var eeMsg
  var eeSocket
  var finished = false

  function onFinish (error) {
    eeMsg.cancel()
    eeSocket.cancel()

    finished = true
    callback(error)
  }

  // Attach event listeners to the message and socket objects.
  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)

  function onSocket (socket) {
    // Remove the listener from the message object.
    msg.removeListener('socket', onSocket)

    if (finished) return
    if (eeMsg !== eeSocket) return

    // Attach event listeners to the socket object.
    eeSocket = first([[socket, 'error', 'close']], onFinish)
  }

  if (msg.socket) {
    // If the socket object is already assigned, attach the listener to it.
    onSocket(msg.socket)
    return
  }

  // Wait for the socket object to be assigned.
  msg.on('socket', onSocket)

  if (msg.socket === undefined) {
    // istanbul ignore next: node.js 0.8 patch
    patchAssignSocket(msg, onSocket)
  }
}

/**
 * Attach the listener to the message.
 *
 * @param {object} msg - The message object to attach the listener to.
 * @return {function} - The listener function.
 * @private
 */

function attachListener (msg, listener) {
  var attached = msg.__onFinished

  // Create a private single listener with a queue.
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg)
    attachFinishedListener(msg, attached)
  }

  // Add the listener to the queue.
  attached.queue.push(listener)
}

/**
 * Create listener on message.
 *
 * @param {object} msg - The message object.
 * @return {function} - The listener function.
 * @private
 */

function createListener (msg) {
  function listener (err) {
    if (msg.__onFinished === listener) msg.__onFinished = null
    if (!listener.queue) return

    var queue = listener.queue
    listener.queue = null

    for (var i = 0; i < queue.length; i++) {
      queue[i](err, msg)
    }
  }

  listener.queue = []

  return listener
}

/**
 * Patch ServerResponse.prototype.assignSocket for node.js 0.8.
 *
 * @param {ServerResponse} res - The response object to patch.
 * @param {function} callback - The callback function to be invoked when the
 *                              socket is assigned.
 * @private
 */

// istanbul ignore next: node.js 0.8 patch
function patchAssignSocket (res, callback) {
  var assignSocket = res.assignSocket

  if (typeof assignSocket !== 'function') return

  // Replace the assignSocket method with
