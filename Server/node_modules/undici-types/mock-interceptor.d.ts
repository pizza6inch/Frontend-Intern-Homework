import { IncomingHttpHeaders } from './header'
import Dispatcher from './dispatcher';
import { BodyInit, Headers } from './fetch'

export {
  Interceptable,
  MockInterceptor,
  MockScope
}

/**
 * The scope associated with a mock dispatch.
 * Defines methods to customize the behavior of a mock dispatch.
 */
declare class MockScope<TData extends object = object> {
  /**
   * Creates a new MockScope instance.
   * @param mockDispatch - The mock dispatch to scope.
   */
  constructor(mockDispatch: MockInterceptor.MockDispatch<TData>);
  /**
   * Delay a reply by a set amount of time in ms.
   * @param waitInMs - The amount of time to delay the reply in ms.
   * @returns The current MockScope instance, allowing for method chaining.
   */
  delay(waitInMs: number): MockScope<TData>;
  /**
   * Persist the defined mock data for the associated reply.
   * It will return the defined mock data indefinitely.
   * @returns The current MockScope instance, allowing for method chaining.
   */
  persist(): MockScope<TData>;
  /**
   * Define a reply for a set amount of matching requests.
   * @param repeatTimes - The number of times to repeat the reply.
   * @returns The current MockScope instance, allowing for method chaining.
   */
  times(repeatTimes: number): MockScope<TData>;
}

/**
 * The interceptor for a Mock.
 * Defines methods to mock undici requests and customize the behavior of the interceptor.
 */
declare class MockInterceptor {
  /**
   * Creates a new MockInterceptor instance.
   * @param options - The options to configure the interceptor.
   * @param mockDispatches - The mock dispatches to use for the interceptor.
   */
  constructor(options: MockInterceptor.Options, mockDispatches: MockInterceptor.MockDispatch[]);
  /**
   * Mock an undici request with the defined reply.
   * @param replyOptionsCallback - A callback function to define the reply options.
   * @returns A new MockScope instance to further customize the mock behavior.
   */
  reply<TData extends object = object>(
    replyOptionsCallback: MockInterceptor.MockReplyOptionsCallback<TData>
  ): MockScope<TData>;
  /**
   * Mock an undici request by throwing the defined reply error.
   * @param error - The error to throw when the mocked request is made.
   * @returns A new MockScope instance to further customize the mock behavior.
   */
  replyWithError<TError extends Error = Error>(error: TError): MockScope;
  /**
   * Set default reply headers on the interceptor for subsequent mocked replies.
   * @param headers - The headers to set as default for subsequent mocked replies.
   * @returns The current MockInterceptor instance, allowing for method chaining.
   */
  defaultReplyHeaders(headers: IncomingHttpHeaders): MockInterceptor;
  /**
   * Set default reply trailers on the interceptor for subsequent mocked replies.
   * @param trailers - The trailers to set as default for subsequent mocked replies.
   * @returns The current MockInterceptor instance, allowing for method chaining.
   */
  defaultReplyTrailers(trailers: Record<string, string>): MockInterceptor;
  /**
   * Set automatically calculated content-length header on subsequent mocked replies.
   * @returns The current MockInterceptor instance, allowing for method chaining.
   */
  replyContentLength(): MockInterceptor;
}

declare namespace MockInterceptor {
  /** MockInterceptor options. */
  export interface Options {
    /** Path to intercept on. */
    path: string | RegExp | ((path: string) => boolean);
    /** Method to intercept on. Defaults to GET. */
    method?: string | RegExp | ((method: string) => boolean);
    /** Body to intercept on. */
    body?: string | RegExp | ((body: string) => boolean);
    /** Headers to intercept on. */
    headers?: Record<string, string | RegExp | ((body: string) => boolean)> | ((headers: Record<string, string
