(function(){ /* Begin anonymous function scope */

var r, t, n, e, i, o, a, s; /* Variable declarations */

t = {}; /* Create an empty object */

s = this; /* Store the global object (either window or global) */

/* If module.exports is defined, export the t object, otherwise add the ipaddr property to the global object */
if (typeof module !== 'undefined' && null !== module && module.exports) {
  module.exports = t;
} else {
  s.ipaddr = t;
}

a = function(r, t, n, e) { /* Function to compare two arrays of numbers */
  var i, o, a, s;
  if (r.length !== t.length) {
    throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
  }
  for (i = 0, o = e; o > 0;) {
    a = n - o, o -= 1;
    if (a < 0) {
      a = 0;
    }
    if (r[i] >> a !== t[i] >> a) {
      return !1;
    }
  }
  return !0;
};

t.subnetMatch = function(r, t, n) { /* Function to find a matching subnet in a set of special ranges */
  var e, i, o, a, s;
  if (null == n) {
    n = "unicast";
  }
  for (o in t) {
    for (a = t[o], e = 0, i = a.length; e < i; e++) {
      if (s = a[e], r.kind() === s[0].kind() && r.match.apply(r, s)) {
        return o;
      }
    }
  }
  return n;
};

t.IPv4 = function() { /* IPv4 constructor */

  function r(r) {
    var t, n, e;
    if (4 !== r.length) {
      throw new Error("ipaddr: ipv4 octet count should be 4");
    }
    for (t = 0, n = r.length; t < n; t++) {
      if (!(0 <= (e = r[t]) && e <= 255)) {
        throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
      }
    }
    this.octets = r;
  }

  r.prototype.kind = function() { /* Return the address kind */
    return "ipv4";
  };

  r.prototype.toString = function() { /* Return the address as a dotted string */
    return this.octets.join(".");
  };

  r.prototype.toNormalizedString = function() { /* Return the address as a normalized dotted string */
    return this.toString();
  };

  r.prototype.toByteArray = function() { /* Return the address as a byte array */
    return this.octets.slice(0);
  };

  r.prototype.match = function(r, t) { /* Check if the address matches a given pattern */
    var n;
    if (void 0 === t && (r = (n = r)[0], t = n[1]), "ipv4" !== r.kind()) {
      throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
    }
    return a(this.octets, r.octets, 8, t);
  };

  r.prototype.SpecialRanges = { /* Define special IPv4 ranges */
    unspecified: [[new r([0, 0, 0, 0]), 8]],
    broadcast: [[new r([255, 255, 255, 255]), 32]],
    multicast: [[new r([224, 0, 0, 0]), 4]],
    linkLocal: [[new r([169, 254, 0, 0]), 16]],
    loopback: [[new r([127, 0, 0, 0]), 8]],
    carrierGradeNat: [[new r([100, 64, 0, 0]), 10]],
    private: [[new r([10, 0, 0, 0]), 8],
              [new r([172, 16, 0, 0]), 12],
              [new r([192, 168, 0, 0]), 16]],
    reserved: [[new r([192, 0, 0, 0]), 24],
               [new r([192, 0, 2, 0]), 24],
               [new r([192, 88, 99, 0]), 24],
               [new r([198, 51, 100, 0]), 24],
               [new r([203, 0, 113, 0]), 24],
               [new r([240, 0, 0, 0]), 4]]
  };

  r.prototype.range = function() { /* Return the range of the address */
    return t.subnetMatch(this, this.SpecialRanges);
  };

  r.prototype.toIPv4MappedAddress = function() { /* Convert the address to an IPv4-mapped IPv6 address */
    return t.IPv6.parse("::ffff:" + this.toString());
  };

  r.prototype.prefixLengthFromSubnetMask = function() { /* Calculate the prefix length from the subnet mask */
    var r, t, n, e, i, o, a;
    for (a = {0: 8, 128: 7, 192: 6, 224: 5, 240: 4, 248: 3, 252: 2, 254: 1, 255: 0}, r =
