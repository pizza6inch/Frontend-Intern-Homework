/*! formdata-polyfill. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */

// Importing 'fetch-blob' and 'fetch-blob/file.js' modules
import C from 'fetch-blob'
import F from 'fetch-blob/file.js'

// Variables and functions declaration
const { toStringTag: t, iterator: i, hasInstance: h } = Symbol
const r = Math.random
const m = 'append,set,get,getAll,delete,keys,values,entries,forEach,constructor'.split(',')
const f = (a, b, c) => (a += '', /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + '' : b[t] === 'File' ? b.name : 'blob', a), b.name !== c || b[t] === 'blob' ? new F([b], c, b) : b] : [a, b + ''])
const e = (n, a, e) => { if (a.length < e) { throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`) } }
const x = (n, a, e) => { if (a.length !== e) { throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`) } }

// Exporting 'File' as an alias for 'fetch-blob/file.js'
export const File = F

/**
 * @type {typeof globalThis.FormData}
 */
// Defining a class 'FormData' that mimics the global 'FormData' object
export const FormData = class {
  #d = []

  // Class constructor
  constructor(...a) {
    if (a.length) throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`)
  }

  // Overriding the toStringTag property
  get [t]() {
    return 'FormData'
  }

  // Overriding the iterator property
  [i]() {
    return this.entries()
  }

  // Overriding the hasInstance method
  static [h](o) {
    return o && typeof o === 'object' && o[t] === 'FormData' && !m.some(m => typeof o[m] !== 'function')
  }

  // Methods for manipulating the data stored in the 'FormData' instance
  append(...a) {
    x('append', arguments, 2)
    this.#d.push(f(...a))
  }

  delete(a) {
    x('delete', arguments, 1)
    a += ''
    this.#d = this.#d.filter(([b]) => b !== a)
  }

  get(a) {
    x('get', arguments, 1)
    a += ''
    for (var b = this.#d, l = b.length, c = 0; c < l; c++) if (b[c][0] === a) return b[c][1]
    return null
  }

  getAll(a, b) {
    x('getAll', arguments, 1)
    b = []
    a += ''
    this.#d.forEach(c => c[0] === a && b.push(c[1]))
    return b
  }

  has(a) {
    x('has', arguments, 1)
    a += ''
    return this.#d.some(b => b[0] === a)
  }

  forEach(a, b) {
    x('forEach', arguments, 1)
    for (var [c, d] of this) a.call(b, d, c, this)
