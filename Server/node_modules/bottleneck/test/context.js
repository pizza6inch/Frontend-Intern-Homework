// Import required modules: Bottleneck for rate limiting and assert for result validation
global.TEST = true
var Bottleneck = require('./bottleneck')
var assert = require('assert')

module.exports = function (options={}) {
  // Helper function to compare JSON-stringified values of two arguments
  var mustEqual = function (a, b) {
    var strA = JSON.stringify(a)
    var strB = JSON.stringify(b)
    if (strA !== strB) {
      console.log(strA + ' !== ' + strB, (new Error('').stack))
      assert(strA === strB)
    }
  }

  // Initialize variables to track execution times and store calls
  var start
  var calls = []

  // Function to set Redis client options based on environment variables and provided options
  var setRedisClientOptions = function (options) {
    options.clearDatastore = true
    if (options.clientOptions == null) {
      options.clientOptions = {
        host: process.env.REDIS_HOST,
        port: process.env.REDIS_PORT,
      }
    }
  }

  // Conditionally set the datastore based on the provided options or environment variables
  if (options.datastore == null && process.env.DATASTORE === 'redis') {
    options.datastore = 'redis'
    setRedisClientOptions(options)
  } else if (options.datastore == null && process.env.DATASTORE === 'ioredis') {
    options.datastore = 'ioredis'
    setRedisClientOptions(options)
  } else {
    options.datastore = 'local'
  }

  // Initialize the Bottleneck limiter with the given options
  var limiter = new Bottleneck(options)

  // Event listener for debugging purposes, logs debug information when an error occurs
  if (!options.errorEventsExpected) {
    limiter.on("error", function (err) {
      console.log('(CONTEXT) ERROR EVENT', err)
    })
  }

  // Ready function to initialize the start time when the limiter is ready
  limiter.ready().then(function (client) {
    start = Date.now()
  })

  // Function to get the current results, including elapsed time, last call duration, and call history
  var getResults = function () {
    return {
      elapsed: Date.now() - start,
      callsDuration: calls.length > 0 ? calls[calls.length - 1].time : null,
      calls: calls
    }
  }

  // Object containing methods to be used in testing
  var context = {
    // Job method to schedule a job with the limiter and track its execution time
    job: function (err, ...result) {
      var cb = result.pop()
      calls.push({err: err, result: result, time: Date.now()-start})
      if (process.env.DEBUG) console.log(result, calls)
      cb.apply({}, [err].concat(result))
    },
    // SlowJob method to schedule a slow job with a specified duration
    slowJob: function (duration, err, ...result) {
      setTimeout(function () {
        var cb = result.pop()
        calls.push({err: err, result: result, time: Date.now()-start})
        if (process.env.DEBUG) console.log(result, calls)
        cb.apply({}, [err].concat(result))
      }, duration)
    },
    // Promise method to schedule a job with the limiter and track its execution time
    promise: function (err, ...result) {
      return new Promise(function (resolve, reject) {
        if (process.env.DEBUG) console.log('In c.promise. Result: ', result)
        calls.push({err: err, result: result, time: Date.now()-start})
        if (process.env.DEBUG) console.log(result, calls)
        if (err === null) {
          return resolve(result)
        } else {
          return reject(err)
        }
      })
    },
    // SlowPromise method to schedule a slow job with a specified duration
    slowPromise: function (duration, err, ...result) {
      return new Promise(function (resolve, reject) {
        setTimeout(function () {
          if (process.env.DEBUG) console.log('In c.slowPromise. Result: ', result)
          calls.push({err: err, result: result, time: Date.now()-start})
          if (process.env.DEBUG) console.log(result, calls)
          if (err === null) {
            return resolve(result)
          } else {
            return reject(err)
          }
        }, duration)
      })
    },
    // pNoErrVal method to schedule a job with the limiter, track its execution time, and compare the result with an expected value
    pNoErrVal: function (promise, ...expected) {
      if (process.env.DEBUG) console.log('In c.pNoErrVal. Expected:', expected)
      return promise.then(function (actual) {
        mustEqual(actual, expected)
      })
    },
    // noErrVal method to compare the error and result with expected values
    noErrVal: function (...expected) {
      return function (err, ...actual) {
        mustEqual(err, null)
        mustEqual(actual, expected)
      }
    },
    // last method to schedule a job with the limiter, track its execution time, and return the results
    last: function (options) {
      var opt = options != null ? options : {}
      return limiter.schedule(opt, function () { return Promise.resolve(getResults()) })
      .catch(function (err) { console.error("Error in context.
