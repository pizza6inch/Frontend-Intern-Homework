var makeTest = require('./context')
var Bottleneck = require('./bottleneck')
var assert = require('assert')

describe('Stop', function () {
  // 'c' is an instance of the limiter created using the makeTest function.
  var c

  // This function is called after each test case to disconnect the limiter.
  afterEach(function () {
    // 'c.limiter.disconnect(false)' disconnects the limiter without waiting for
    // any remaining tasks to complete.
    return c.limiter.disconnect(false)
  })

  it('Should stop and drop the queue', function (done) {
    c = makeTest({
      // Configuring the limiter with maxConcurrent as 2, minTime as 100ms,
      // and trackDoneStatus as true.
      maxConcurrent: 2,
      minTime: 100,
      trackDoneStatus: true
    })
    var submitFailed = false
    var queuedDropped = false
    var scheduledDropped = false
    var dropped = 0

    // Event listener for the 'dropped' event, which increments the 'dropped'
    // variable when a task is dropped from the queue.
    c.limiter.on('dropped', function () {
      dropped++
    })

    // Scheduling a task with id '0' and executing the promise.
    c.pNoErrVal(c.limiter.schedule({id: '0'}, c.promise, null, 0), 0)

    // Scheduling a task with id '1' and executing the slowPromise after 100ms.
    c.pNoErrVal(c.limiter.schedule({id: '1'}, c.slowPromise, 100, null, 1), 1)

    // Scheduling a task with id '2' and expecting the error message 'Dropped!'.
    c.limiter.schedule({id: '2'}, c.promise, null, 2)
    .catch(function (err) {
      c.mustEqual(err.message, 'Dropped!')
      scheduledDropped = true
    })

    // Scheduling a task with id '3' and expecting the error message 'Dropped!'.
    c.limiter.schedule({id: '3'}, c.promise, null, 3)
    .catch(function (err) {
      c.mustEqual(err.message, 'Dropped!')
      queuedDropped = true
    })

    // Setting a timeout to check the counts after 125ms.
    setTimeout(function () {
      var counts = c.limiter.counts()
      c.mustEqual(counts.RECEIVED, 0)
      c.mustEqual(counts.QUEUED, 1)
      c.mustEqual(counts.RUNNING, 1)
      c.mustEqual(counts.EXECUTING, 1)
      c.mustEqual(counts.DONE, 1)

      // Stopping the limiter and expecting certain conditions to be met.
      c.limiter.stop({
        enqueueErrorMessage: 'Stopped!',
        dropErrorMessage: 'Dropped!'
      })
      .then(function () {
        counts = c.limiter.counts()
        c.mustEqual(submitFailed, true)
        c.mustEqual(scheduledDropped, true)
        c.mustEqual(queuedDropped, true)
        c.mustEqual(dropped, 2)
        c.mustEqual(counts.RECEIVED, 0)
        c.mustEqual(counts.QUEUED, 0)
        c.mustEqual(counts.RUNNING, 0)
        c.mustEqual(counts.EXECUTING, 0)
        c.mustEqual(counts.DONE, 2)

        // Checking the results order.
        c.checkResultsOrder([[0], [1]])
        done()
      })

      // Scheduling a task after stopping the limiter and expecting the error
      // message 'Stopped!'.
      c.limiter.schedule(() => Promise.resolve(true))
      .catch(function (err) {
        c.mustEqual(err.message, 'Stopped!')
        submitFailed = true
      })

    }, 125)
  })

  // ... Remaining test cases follow the same format.
})
