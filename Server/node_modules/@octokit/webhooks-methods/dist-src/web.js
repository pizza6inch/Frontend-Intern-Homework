// Import the 'Algorithm' type from './types.js' and the 'getAlgorithm' utility function from './utils.js'
import { Algorithm } from "./types.js";
import { getAlgorithm } from "./utils.js";

// Import the 'TextEncoder' class from the built-in 'encoding' module
import { TextEncoder } from "encoding";

// Define a function 'hexToUInt8Array' that converts a hexadecimal string to a Uint8Array
function hexToUInt8Array(string) {
  // Use a regular expression to extract pairs of hexadecimal digits from the input string
  const pairs = string.match(/[\dA-F]{2}/gi);
  // Convert each pair of hexadecimal digits to an integer and create a new Uint8Array with those integers
  const integers = pairs.map(function(s) {
    return parseInt(s, 16);
  });
  return new Uint8Array(integers);
}

// Define a function 'UInt8ArrayToHex' that converts a Uint8Array to a hexadecimal string
function UInt8ArrayToHex(signature) {
  // Convert each byte of the Uint8Array to a hexadecimal string and join them together
  return Array.prototype.map.call(new Uint8Array(signature), (x) => x.toString(16).padStart(2, "0")).join("");
}

// Define a function 'getHMACHashName' that returns the name of the HMAC hash algorithm given an 'Algorithm' value
function getHMACHashName(algorithm) {
  return {
    [Algorithm.SHA1]: "SHA-1",
    [Algorithm.SHA256]: "SHA-256"
  }[algorithm];
}

// Define an asynchronous function 'importKey' that imports a secret key into the Web Crypto API
async function importKey(secret, algorithm) {
  // Import the secret key in raw format and return a key object that can be used for signing and verifying
  return crypto.subtle.importKey(
    "raw",
    // raw format of the key - should be Uint8Array
    enc.encode(secret),
    {
      // algorithm details
      name: "HMAC",
      hash: { name: getHMACHashName(algorithm) }
    },
    false,
    // export = false
    ["sign", "verify"]
    // what this key can do
  );
}

// Define an asynchronous function 'sign' that generates a digital signature for a given payload using the HMAC algorithm
async function sign(options, payload) {
  // Extract the 'secret' and 'algorithm' values from the 'options' object
  const { secret, algorithm } = typeof options === "object" ? {
    secret: options.secret,
    algorithm: options.algorithm || Algorithm.SHA256
  } : { secret: options, algorithm: Algorithm.SHA256 };
  // Throw an error if the 'secret' or 'payload' is not provided
  if (!secret || !payload) {
    throw new TypeError(
      "[@octokit/webhooks-methods] secret & payload required for sign()"
    );
  }
  // Throw an error if the 'payload' is not a string
  if (typeof payload !== "string") {
    throw new TypeError("[@octokit/webhooks-methods] payload must be a string");
  }
  // Throw an error if the 'algorithm' is not supported
  if (!Object.values(Algorithm).includes(algorithm)) {
    throw new TypeError(
      `[@octokit/webhooks] Algorithm ${algorithm} is not supported. Must be  'sha1' or 'sha256'`
    );
  }
  // Generate the digital signature by signing the payload with the HMAC algorithm
  const signature = await crypto.subtle.sign(
    "HMAC",
    await importKey(secret, algorithm),
    enc.encode(payload)
  );
  // Return the digital signature as a string in the format 'algorithm=hexadecimal-string'
 
