// MakeTest is a function that returns an object containing a Bottleneck limiter
// instance and other helper methods. The 'trackDoneStatus' option is set to true
// to track the DONE status of the limiter.
var makeTest = require('./context')
var Bottleneck = require('./bottleneck')
var assert = require('assert')
var child_process = require('child_process')

describe('Retries', function () {
  var c; // The 'c' variable is an object returned by the makeTest function.

  // The 'afterEach' hook disconnects the limiter after each test.
  afterEach(function () {
    return c.limiter.disconnect(false)
  })

  // The first test checks if the limiter retries when requested by the user
  // (sometimes).
  it('Should retry when requested by the user (sync)', async function () {
    c = makeTest({ trackDoneStatus: true })
    var failedEvents = 0 // Counts the number of failed events.
    var retryEvents = 0 // Counts the number of failed events.

    // The 'failed' event handler is called when a job fails to execute.
    c.limiter.on('failed', function (error, info) {
      c.mustEqual(c.limiter.counts().EXECUTING, 1) // Checks if there is one job executing.
      c.mustEqual(info.retryCount, failedEvents) // Checks the retry count.
      failedEvents++ // Increments the failed events counter.
      return 50 // Returns a value to be used as the next delay.
    })

    // The 'retry' event handler is called when a job is retried.
    c.limiter.on('retry', function (error, info) {
      c.mustEqual(c.limiter.counts().EXECUTING, 1) // Checks if there is one job executing.
      retryEvents++ // Increments the retry events counter.
    })

    // The 'job' function returns a rejected job if the 'times' variable is less
    // than or equal to 2, otherwise it returns a resolved job.
    var times = 0
    const job = function () {
      times++
      if (times <= 2) {
        return Promise.reject(new Error('boom'))
      }
      return Promise.resolve('Success!')
    }

    // The 'mustEqual' method checks if the returned value is equal to 'Success!'.
    c.mustEqual(await c.limiter.schedule(job), 'Success!')
    const results = await c.results()
    // The 'elapsed' property of the results object should be greater than 90
    // and less than 130.
    assert(results.elapsed > 90 && results.elapsed < 130)
    c.mustEqual(failedEvents, 2) // Checks the number of failed events.
    c.mustEqual(retryEvents, 2) // Checks the number of retry events.
    c.mustEqual(c.limiter.counts().EXECUTING, 0) // Checks if there are no jobs executing.
    c.mustEqual(c.limiter.counts().DONE, 1) // Checks if there is one job done.
  })

  // The second test checks if the limiter retries when requested by the user
  // (asynchronously).
  it('Should retry when requested by the user (async)', async function () {
    // The 'c' object is initialized the same way as in the previous test.
    c = makeTest({ trackDoneStatus: true })
    var failedEvents = 0
    var retryEvents = 0

    // The event handlers are the same as in the previous test.
    c.limiter.on('failed', function (error, info) {
      c.mustEqual(c.limiter.counts().EXECUTING, 1)
      c.mustEqual(info.retryCount, failedEvents)
      failedEvents++
      return Promise.resolve(50)
    })

    c.limiter.on('retry', function (error, info) {
      c.mustEqual(c.limiter.counts().EXECUTING, 1)
      retryEvents++
    })

    // The 'job' function is the same as in the previous test.
    var times = 0
    const retryJob = function () {
      times++
      if (times <= 2) {
        return Promise.reject(new Error('boom'))
      }
      return Promise.resolve('Success!')
    }

    // The 'mustEqual' method checks if the returned value is equal to 'Success!'.
    c.mustEqual(await c.limiter.schedule(retryJob), 'Success!')
    const results = await c.results()
    assert(results.elapsed > 90 && results.elapsed < 130)
    c.mustEqual(failedEvents, 2)
    c.mustEqual(retryEvents, 2)
    c.mustEqual(c.limiter.counts().EXECUTING, 0)
    c.mustEqual(c.limiter.counts().DONE, 1)
  })

  // The third test checks if the limiter does not retry when the user returns
  // an error.
  it('Should not retry when user returns an error (sync)', async function () {
    // The 'c' object is initialized with the 'errorEventsExpected' option set to
    // true to expect error.
    c = makeTest({ errorEventsExpected: true, trackDoneStatus: true })
    var failedEvents = 0
    var retryEvents = 0
    var errorEvents = 0
    var caught = false

    // The 'failed' event handler is the same as in the previous tests.
    c.limiter.on('failed', function (error, info) {
      c.mustEqual(c.limiter.counts().EXECUTING, 1)
      c.mustEqual(info.retryCount, failedEvents)
      failedEvents++
      throw new Error('Nope')
    })

    // The 'retry' event handler is the same as in the previous tests.
    c.limiter.on
