// Import required modules: timingSafeEqual from node:crypto, Buffer from node:buffer,
// sign function from the local sign.js file, VERSION from ../version.js,
// and getAlgorithm function from ../utils.js.
import { timingSafeEqual } from "node:crypto";
import { Buffer } from "node:buffer";
import { sign } from "./sign.js";
import { VERSION } from "../version.js";
import { getAlgorithm } from "../utils.js";

/**
 * Asynchronously verifies the given signature of the eventPayload using the secret.
 *
 * @param {string} secret - The secret used for signing.
 * @param {string} eventPayload - The payload received from the event source.
 * @param {string} signature - The signature received from the event source.
 * @throws {TypeError} If secret, eventPayload, or signature is missing or eventPayload is not a string.
 * @returns {boolean} True if the signature matches, false otherwise.
 */
async function verify(secret, eventPayload, signature) {
  if (!secret || !eventPayload || !signature) {
    throw new TypeError(
      "[@octokit/webhooks-methods] secret, eventPayload & signature required"
    );
  }
  if (typeof eventPayload !== "string") {
    throw new TypeError(
      "[@octokit/webhooks-methods] eventPayload must be a string"
    );
  }

  // Convert the signature to a Buffer.
  const signatureBuffer = Buffer.from(signature);

  // Get the algorithm used for signing from the signature.
  const algorithm = getAlgorithm(signature);

  // Sign the eventPayload using the secret and the algorithm.
  const verificationBuffer = Buffer.from(
    await sign({ secret, algorithm }, eventPayload)
  );

  // If the lengths of the signature and verificationBuffer are not equal, return false.
  if (signatureBuffer.length !== verificationBuffer.length) {
    return false;
  }

  // Compare the signature and verificationBuffer using the timingSafeEqual function.
  return timingSafeEqual(signatureBuffer, verificationBuffer);
}

