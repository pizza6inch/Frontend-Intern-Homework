"use strict";

// Import required modules
const parser = require("./parser");
const Events = require("./Events");
const RedisConnection = require("./RedisConnection");
const IORedisConnection = require("./IORedisConnection");
const Scripts = require("./Scripts");

// Define the Group class
class Group {
  // Constructor function for Group class
  constructor(limiterOptions = {}) {
    // Bind the deleteKey method to the class instance
    this.deleteKey = this.deleteKey.bind(this);

    // Set the limiterOptions and instantiate the Events class
    this.limiterOptions = limiterOptions;
    this.Events = new Events(this);

    // Initialize the instances object and import the Bottleneck module
    this.instances = {};
    this.Bottleneck = require("./Bottleneck");

    // Start the auto-cleanup process
    this._startAutoCleanup();

    // Check if a connection is provided and initialize it if necessary
    this.sharedConnection = this.connection != null;

    if (this.connection == null) {
      if (this.limiterOptions.datastore === "redis") {
        this.connection = new RedisConnection(Object.assign({}, this.limiterOptions, {
          Events: this.Events
        }));
      } else if (this.limiterOptions.datastore === "ioredis") {
        this.connection = new IORedisConnection(Object.assign({}, this.limiterOptions, {
          Events: this.Events
        }));
      }
    }
  }

  // Method to get or create a new limiter instance
  key(key = "") {
    // If the instances object already has a key, return it
    if (this.instances[key]) {
      return this.instances[key];
    }

    // Otherwise, create a new limiter instance and add it to the instances object
    const limiter = this.instances[key] = new this.Bottleneck(Object.assign(this.limiterOptions, {
      id: `${this.id}-${key}`,
      timeout: this.timeout,
      connection: this.connection
    }));

    // Trigger the created event
    this.Events.trigger("created", limiter, key);

    return limiter;
  }

  // Method to delete a limiter instance and its associated keys
  deleteKey(key = "") {
    // Run the necessary Redis commands to delete the keys and disconnect the limiter instance
    return _asyncToGenerator(function* () {
      let deleted, instance;
      instance = this.instances[key];

      if (this.connection) {
        deleted = yield this.connection.__runCommand__(['del', ...Scripts.allKeys(`${this.id}-${key}`)]);
      }

      if (instance != null) {
        delete this.instances[key];
        yield instance.disconnect();
      }

      return instance != null || deleted > 0;
    }).bind(this)();
  }

  // Method to get an array of all limiter instances
  limiters() {
    // Iterate over the instances object and return an array of objects containing the key and limiter instance
    const ref = this.instances;
    const results = [];

    for (let k in ref) {
      const v = ref[k];
      results.push({
        key: k,
        limiter: v
      });
    }

    return results;
  }

  // Method to get an array of all keys
  keys() {
    return Object.keys(this.instances);
  }

  // Method to get an array of all cluster keys
  clusterKeys() {
    // Run the necessary Redis commands to get an array of all cluster keys
    return _asyncToGenerator(function* () {
      let cursor, end, found, i, k, keys, len, next, start;

      if (this.connection == null) {
        return this.Promise.resolve(this.keys());
      }

      keys = [];
      cursor = null;
      start = `b_${this.id}-`.length;
      end = "_settings".length;

      while (cursor !== 0) {
        const _ref = yield this.connection.__runCommand__(["scan", cursor != null ? cursor : 0, "match", `b_${this.id}-*_settings`, "count", 10000]);

        const _ref2 = _slicedToArray(_ref, 2);

        next = _ref2[0];
        found = _ref2[1];
        cursor = ~~next;

        for (i = 0, len = found.length; i < len; i++) {
          k = found[i];
          keys.push(k.slice(start, -end));
        }
      }

      return keys;
    }).bind(this)();
  }

  // Method to start the auto-cleanup process
  _startAutoCleanup() {
    // Set the interval for the auto-cleanup process
    let base;
    clearInterval(this.interval);
    return typeof (base = this.interval = setInterval(
    /*#__PURE__*/
    _asyncToGenerator(function* () {
      let e, k, ref, results, time, v;
      time = Date.now();
      ref = this.instances;
      results = [];

      for (k in ref) {
        v = ref[k];

        try {
          if (yield v._store.__groupCheck__(time)) {
            results.push(this.deleteKey(k));
          } else {
            results.push(void 0);
          }
        } catch (error) {
          e = error;
          results.push(v.Events.trigger("error", e));
        }
      }

      return results;
    }), this.timeout / 2)).unref === "function" ? base.unref() : void 0;
  }

  // Method to update the settings for the limiter instances
  updateSettings(options = {}) {
    // Overwrite the default options and lim
