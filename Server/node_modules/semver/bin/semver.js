// Standalone semver comparison program.
// Exits successfully and prints matching version(s) if
// any supplied version is valid and passes all tests.

const argv = process.argv.slice(2) // Get command line arguments, excluding the node and script name

let versions = [] // Array to store version strings

const range = [] // Array to store version ranges

let inc = null // Variable to store the increment level

// Get the version from the package.json file
const version = require('../package.json').version

let loose = false // Flag to enable loose mode

let includePrerelease = false // Flag to include prerelease versions

let coerce = false // Flag to coerce strings into SemVer objects

let rtl = false // Flag to enable right-to-left coercion

let identifier

let identifierBase

const semver = require('../') // Import the semver module
const parseOptions = require('../internal/parse-options') // Import the parse-options module

let reverse = false // Flag to reverse the order of the output

let options = {} // Object to store the parsed options

// Main function to parse the command line arguments and perform the comparison
const main = () => {
  if (!argv.length) {
    return help() // Print help message if no arguments are provided
  }
  while (argv.length) {
    let a = argv.shift() // Get the next argument
    const indexOfEqualSign = a.indexOf('=') // Check if the argument contains an equal sign
    if (indexOfEqualSign !== -1) {
      const value = a.slice(indexOfEqualSign + 1) // Extract the value after the equal sign
      a = a.slice(0, indexOfEqualSign) // Remove the value from the argument
      argv.unshift(value) // Add the value to the beginning of the arguments array
    }
    switch (a) {
      case '-rv': case '-rev': case '--rev': case '--reverse':
        reverse = true // Set the reverse flag
        break
      case '-l': case '--loose':
        loose = true // Set the loose flag
        break
      case '-p': case '--include-prerelease':
        includePrerelease = true // Set the includePrerelease flag
        break
      case '-v': case '--version':
        versions.push(argv.shift()) // Add the version to the versions array
        break
      case '-i': case '--inc': case '--increment':
        switch (argv[0]) {
          case 'major': case 'minor': case 'patch': case 'prerelease':
          case 'premajor': case 'preminor': case 'prepatch':
            inc = argv.shift() // Set the increment level
            break
          default:
            inc = 'patch' // Set the default increment level
            break
        }
        break
      case '--preid':
        identifier = argv.shift() // Set the preid identifier
        break
      case '-r': case '--range':
        range.push(argv.shift()) // Add the range to the ranges array
        break
      case '-n':
        identifierBase = argv.shift() // Set the identifier base
        if (identifierBase === 'false') {
          identifierBase = false // Set the identifier base to false
        }
        break
      case '-c': case '--coerce':
        coerce = true // Set the coerce flag
        break
      case '--rtl':
        rtl = true // Set the rtl flag
        break
      case '--ltr':
        rtl = false // Set the ltr flag
        break
      case '-h': case '--help': case '-?':
        return help() // Print help message
      default:
        versions.push(a) // Add the version to the versions array
        break
    }
  }

  options = parseOptions({ loose, includePrerelease, rtl }) // Parse the options

  versions = versions.map((v) => {
    return coerce ? (semver.coerce(v, options) || { version: v }).version : v
  }).filter((v) => {
    return semver.valid(v) // Filter out invalid versions
  })
  if (!versions.length) {
    return fail() // Fail if no valid versions are found
  }
  if (inc && (versions.length !== 1 || range.length)) {
    return failInc() // Fail if increment is used with multiple versions or ranges
  }

  for (let i = 0, l = range.length; i < l; i++) {
    versions = versions.filter((v) => {
      return semver.satisfies(v, range[i], options) // Filter out versions that don't satisfy the range
    })
    if (!versions.length) {
      return fail() // Fail if no versions satisfy the range
    }
  }
  return success(versions) // Print the satisfying versions
}

const failInc = () => {
  console.error('--inc can only be used on a single version with no range') // Print error message
  fail() // Fail
}

const fail = () => process.exit(1) // Fail and exit with code 1

const success = (versions) => {
  const compare = reverse ? 'rcompare' : 'compare' // Set the compare function based on the reverse flag
  versions.sort((a, b) => {
    return semver[compare](a, b, options) // Sort the versions based on the compare function
  }).map((v) => {
    return semver.clean(v, options) // Clean the versions
  }).map((v) => {
    return inc ? semver.inc(v, inc, options, identifier, identifierBase) : v // Increment the versions if necessary
  }).forEach((v, i, _) => {
    console.log(v) // Print the satisfying versions
  })
}

const help = () => console.log(
`SemVer ${version}

A JavaScript implementation of the https://semver.org/ specification
Copyright Isaac Z. Schlueter

Usage: semver [options] <version> [<version> [...]]
Prints valid versions sorted by SemVer precedence

Options:
-r --range
