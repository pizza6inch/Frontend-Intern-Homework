"use strict";

// Define an async generator step function for handling asynchronous generator functions
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

// Convert a generator function into an asynchronous function using async-generator functions
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

// Define the Events class, which provides an event emitter for a given instance
var Events = (function () {
  function Events(instance) {
    this.instance = instance;
    this._events = {}; // Store all registered event listeners

    // Check if an emitter already exists for the instance, and throw an error if it does
    if (
      this.instance.on != null ||
      this.instance.once != null ||
      this.instance.removeAllListeners != null
    ) {
      throw new Error("An Emitter already exists for this object");
    }

    // Define on, once, and removeAllListeners methods for the instance
    this.instance.on = (name, cb) => {
      return this._addListener(name, "many", cb);
    };

    this.instance.once = (name, cb) => {
      return this._addListener(name, "once", cb);
    };

    this.instance.removeAllListeners = (name = null) => {
      if (name != null) {
        return delete this._events[name];
      } else {
        return (this._events = {});
      }
    };
  }

  // Add a listener for a given event name with a specific status (many or once)
  this._addListener = function (name, status, cb) {
    var base;

    if ((base = this._events)[name] == null) {
      base[name] = [];
    }

    this._events[name].push({
      cb,
      status,
    });

    return this.instance;
  };

  // Get the number of listeners for a given event name
  this.listenerCount = function (name) {
    if (this._events[name] != null) {
      return this._events[name].length;
    } else {
      return 0;
    }
  };

  // Trigger an event and execute all registered listeners for the event
  this.trigger = _asyncToGenerator(function* (name, ...args) {
    var e, promises;

    try {
      // Log the event trigger if the name is not "debug"
      if (name !== "debug") {
        this.trigger("debug", `Event triggered: ${name}`, args);
      }

      // Check if there are any listeners for the event, and return if there are none
      if (this._events[name] == null) {
        return;
      }

      // Filter out listeners with a status of "none"
      this._events[name] = this._events[name].filter(function (listener) {
        return listener.status !== "none";
      });

      // Create an array of promises for each listener
      promises = this._events[name].map(
        /*#__PURE__*/
        function () {
          var _ref = _asyncToGenerator(function* (listener) {
            var e, returned;

            if (listener.status === "none") {
              return;
            }

            if (listener.status === "once") {
              listener.status = "none";
            }

            try {
              // Execute the listener and get the returned value
              returned =
                typeof listener.cb === "function"
                  ? listener.cb(...args)
                  : void 0;

              // If the returned value is a promise, await it
              if (
                typeof (returned != null ? returned.then : void 0) ===
                "function"
              ) {
                return yield returned;
              } else {
                return returned;
              }
            } catch (error) {
              e = error;

              // If the error name is not "error", trigger the "error" event
              if ("name" !== "error") {
                this.trigger("error", e);
              }

              return null;
            }
          });

          return function (_x) {
            return _ref.apply(this, arguments);
          };
        }.bind(this)
      );

      // Wait for all promises to resolve, and return the first non-null value
      return (yield Promise.all(promises)).find(function (x) {
        return x != null;
      });
    } catch (error) {
      e = error;

      // If the error name is not "error", trigger the "error" event
      if ("name" !== "error") {
        this.trigger("error", e);
      }

      return null;
    }
  });

 
