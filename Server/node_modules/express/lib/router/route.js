/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict';

// Import required modules
var debug = require('debug')('express:router:route');
var flatten = require('array-flatten');
var Layer = require('./layer');
var methods = require('methods');

// Import utility functions
var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

// Export the Route constructor
module.exports = Route;

// Initialize a new Route with the given path
function Route(path) {
  // The path that the route should listen on
  this.path = path;

  // An array of layers that define the handlers for the route
  this.stack = [];

  // Log the creation of the new route
  debug('new %o', path)

  // An object that maps HTTP methods to booleans
  // indicating whether the route handles the method
  this.methods = {};
}

// Determine if the route handles a given method
Route.prototype._handles_method = function _handles_method(method) {
  // If the route handles all methods, return true
  if (this.methods._all) {
    return true;
  }

  // Convert the method name to lowercase
  var name = method.toLowerCase();

  // If the method is HEAD and the route doesn't handle HEAD,
  // try GET instead
  if (name === 'head' && !this.methods['head']) {
    name = 'get';
  }

  // Return true if the route handles the method
  return Boolean(this.methods[name]);
};

// Return an array of supported HTTP methods
Route.prototype._options = function _options() {
  // Get an array of the method names that the route handles
  var methods = Object.keys(this.methods);

  // Append 'HEAD' to the array if the route handles 'GET' but not 'HEAD'
  if (this.methods.get && !this.methods.head) {
    methods.push('head');
  }

  // Convert each method name to uppercase
  for (var i = 0; i < methods.length; i++) {
    methods[i] = methods[i].toUpperCase();
  }

  // Return the array of method names
  return methods;
};

// Dispatch a request to the appropriate handler
Route.prototype.dispatch = function dispatch(req, res, done) {
  // Initialize variables
  var idx = 0;
  var stack = this.stack;
  var sync = 0

  // If the stack is empty, call the done callback
  if (stack.length === 0) {
    return done();
  }

  // Get the HTTP method of the request
  var method = req.method.toLowerCase();

  // If the method is HEAD and the route doesn't handle HEAD,
  // use GET instead
  if (method === 'head' && !this.methods['head']) {
    method = 'get';
  }

  // Set the route property of the request object
  req.route = this;

  // Call the next middleware function
  next();

  // A helper function for dispatching the request
  function next(err) {
    // If there was an error and the error is 'route',
    // call the done callback
    if (err && err === 'route') {
      return done();
    }

    // If there was an error and the error is 'router',
    // call the done callback with the error
    if (err && err === 'router') {
      return done(err)
    }

    // Increment the synchronous stack counter
    if (++sync > 100) {
      return setImmediate(next, err)
    }

    // Get the next layer in the stack
    var layer = stack[idx++]

    // If there are no more layers, call the done callback
    if (!layer) {
      return done(err)
    }

    // If the layer doesn't handle the current HTTP method,
    // call the next middleware function
    if (layer.method && layer.method !== method) {
      next(err)
    } else if (err) {
      // If there was an error, call the layer's error handler
      layer.handle_error(err, req, res, next);
    } else {
      // If there was no error, call the layer's request handler
      layer.handle_request(req, res, next);
    }

    // Reset the synchronous stack counter
    sync = 0
  }
};

// Add a handler for all HTTP verbs to this route
Route.prototype.all = function all() {
  // Flatten the arguments array
  var handles = flatten(slice.call(arguments));

  // Iterate over each handler
  for (var i = 0; i < handles.length; i++) {
    var handle = handles[i];

    //
