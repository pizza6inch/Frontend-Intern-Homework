// Function to encode reserved characters in a string
function encodeReserved(str) {
  // Split the string into parts based on the regex pattern
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    // If the part does not contain a percent sign followed by hexadecimal digits
    if (!/%[0-9A-Fa-f]/.test(part)) {
      // Encode the part using encodeURI and replace %5B and %5D with [ and ] respectively
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    // Return the part
    return part;
  }).join("");
}

// Function to encode unreserved characters in a string
function encodeUnreserved(str) {
  // Replace !'()* with their corresponding percent-encoded values
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

// Function to encode a value based on the operator and key
function encodeValue(operator, value, key) {
  // If the operator is + or #, encode the value using encodeReserved
  // Otherwise, encode the value using encodeUnreserved
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  // If the key is defined, return the encoded key followed by the equals sign and encoded value
  // Otherwise, return the encoded value
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}

// Function to check if a value is defined
function isDefined(value) {
  return value !== void 0 && value !== null;
}

// Function to check if the operator is a key operator
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}

// Function to get the values for a key based on the context, operator, and modifier
function getValues(context, operator, key, modifier) {
  // Get the value for the key from the context
  var value = context[key], result = [];
  // If the value is defined and not an empty string
  if (isDefined(value) && value !== "") {
    // If the value is a string, number, or boolean
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      // Convert the value to a string
      value = value.toString();
      // If the modifier is defined and not equal to "*"
      if (modifier && modifier !== "*") {
        // Get the substring of the value based on the modifier
        value = value.substring(0, parseInt(modifier, 10));
      }
      // Add the encoded value to the result array
      result.push(
        encodeValue(operator, value, isKeyOperator(operator) ? key : "")
      );
    // If the value is an array or an object
    } else {
      // If the modifier is equal to "*"
      if (modifier === "*") {
        // If the value is an array
        if (Array.isArray(value)) {
          // Filter out undefined and null values from the array and encode each value
          value.filter(isDefined).forEach(function(value2) {
            result.push(
              encodeValue(operator, value2, isKeyOperator(operator) ? key : "")
            );
          });
        // If the value is an object
        } else {
          // Iterate over the keys and values of the object
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              // Encode the key and value and add them to the result array
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      // If the modifier is not equal to "*"
      } else {
        // Create a temporary array
        const tmp = [];
        // If the value is an array
        if (Array.isArray(value)) {
          // Filter out undefined and null values from the array and encode each value
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        // If the value is an object
        } else {
          // Iterate over the keys and values of the object
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k])) {
              // Encode the key and value and add them to the temporary array
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }
        // If the operator is a key operator
        if (isKeyOperator(operator)) {
          // Encode the key and join the temporary array with a comma
          // Add the encoded key and the joined array to the result array
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        // If the temporary array is not empty
        } else if (tmp.length !== 0) {
          // Join the temporary array with a comma and add it to the result array
          result.push(tmp.join(","));
        }
      }
    }
  // If the value is undefined or an empty string
  } else {
    // If the operator is ;
    if (operator === ";") {
      // If the value is defined, add the encoded key to the result array
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      // If the value is an empty string, add an empty string to the result array
      } else {
        result.push("");
      }
    // If the operator is & or ? and the value is an empty string
    } else if (value === "" && (operator === "&" || operator === "?")) {
      // Add the encoded key followed by an equals sign to the result
