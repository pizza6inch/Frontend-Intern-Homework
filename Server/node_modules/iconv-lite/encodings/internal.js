"use strict";

// The module exports Node.js internal encodings.
module.exports = {
    // Encodings
    utf8:   { type: "_internal", bomAware: true},
    cesu8:  { type: "_internal", bomAware: true},
    unicode11utf8: "utf8",

    ucs2:   { type: "_internal", bomAware: true},
    utf16le: "ucs2",

    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex:    { type: "_internal" },

    // Codec.
    _internal: InternalCodec,
};

//------------------------------------------------------------------------------

// Constructor function for creating an InternalCodec object.
function InternalCodec(codecOptions, iconv) {
    // Store the encoding name and bomAware property from codecOptions.
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;

    // Set the encoder based on the encoding name.
    if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
        this.enc = "utf8"; // Use utf8 for decoding.
        this.encoder = InternalEncoderCesu8;

        // Add decoder for versions of Node not supporting CESU-8
        if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== 'ðŸ’©') {
            this.decoder = InternalDecoderCesu8;
            this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
    }
}

// Set encoder and decoder prototype properties for InternalCodec instances.
InternalCodec.prototype.encoder = InternalEncoder;
InternalCodec.prototype.decoder = InternalDecoder;

//------------------------------------------------------------------------------

// Import the StringDecoder class from the 'string_decoder' module.
var StringDecoder = require('string_decoder').StringDecoder;

// Add an end method to the StringDecoder prototype if it doesn't exist.
if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {};


// Constructor function for creating an InternalDecoder object.
function InternalDecoder(options, codec) {
    // Call the StringDecoder constructor with the encoding.
    StringDecoder.call(this, codec.enc);
}

// Set the InternalDecoder prototype to the StringDecoder prototype.
InternalDecoder.prototype = StringDecoder.prototype;


//------------------------------------------------------------------------------

// Constructor function for creating an InternalEncoder object.
function InternalEncoder(options, codec) {
    this.enc = codec.enc;
}

// Encoder write method that returns a Buffer from the input string.
InternalEncoder.prototype.write = function(str) {
    return Buffer.from(str, this.enc);
}

// Encoder end method that does nothing.
InternalEncoder.prototype.end = function() {
}


//------------------------------------------------------------------------------

// Constructor function for creating an InternalEncoderBase64 object.
function InternalEncoderBase64(options, codec) {
    this.prevStr = '';
}

// Encoder write method that returns a Buffer from the input string with base64 encoding.
InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - (str.length % 4);
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);

    return Buffer.from(str, "base64");
}

// Encoder end method that returns a Buffer from the remaining base64 encoded string.
InternalEncoderBase64.prototype.end = function() {
    return Buffer.from(this.prevStr, "base64");
}


//------------------------------------------------------------------------------

// Constructor function for creating an InternalEncoderCesu8 object.
function InternalEncoderCesu8(options, codec) {
}

// Encoder write method that returns a Buffer from the input string with CESU-8 encoding.
InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        // Naive implementation, but it works because CESU-8 is especially easy
        // to convert from UTF-16 (which all JS strings are encoded in).
        if (charCode < 0x80)
            buf[bufIdx++] = charCode;
        else if (charCode < 0x800) {
            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
        else { // charCode will always be < 0x10000 in javascript.
            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
    }
    return buf.slice(0, bufIdx);
}

// Encoder end method that does nothing.
InternalEncoderCesu8.prototype.end = function() {
}

//------------------------------------------------------------------------------

// Constructor function for creating an InternalDecoderCesu8 object.
function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
}

// Decoder write method that returns a decoded string from the input Buffer.
InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc
