import { isPlainObject } from "./is-plain-object.js";
import { RequestError } from "@octokit/request-error";
import getBuffer from "./get-buffer-response.js";

// fetchWrapper function is a custom implementation of the global fetch function
// It takes a requestOptions object as a parameter and returns a Promise that resolves to a response object
function fetchWrapper(requestOptions) {
  // Destructuring the log property from requestOptions.request object
  // If log property is not present in requestOptions.request object, then it defaults to console
  const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
  
  // A flag to check if parseSuccessResponseBody property is present in requestOptions.request object
  // If present and set to false, then response body is not parsed
  const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;
  
  // Check if requestOptions.body is a plain object or an array
  // If yes, then stringify it before sending the request
  if (isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }
  
  // Initializing headers, status, url, and fetch variables
  let headers = {};
  let status;
  let url;
  let { fetch } = globalThis;
  
  // If requestOptions.request object has a fetch property, then it overrides the global fetch function
  if (requestOptions.request?.fetch) {
    fetch = requestOptions.request.fetch;
  }
  
  // Throwing an error if fetch function is not present
  if (!fetch) {
    throw new Error(
      "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
    );
  }
  
  // Returning a Promise that resolves to a response object
  return fetch(requestOptions.url, {
    method: requestOptions.method,
    body: requestOptions.body,
    headers: requestOptions.headers,
    signal: requestOptions.request?.signal,
    // duplex must be set if request.body is ReadableStream or Async Iterables.
    // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
    ...requestOptions.body && { duplex: "half" }
  }).then(async (response) => {
    // Initializing url, status, and headers variables with response object properties
    url = response.url;
    status = response.status;
    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }
    
    // Checking if response object has a deprecation property
    // If yes, then log a warning message with deprecation and sunset properties
    if ("deprecation" in headers) {
      const matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/);
      const deprecationLink = matches && matches.pop();
      log.warn(
        `[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`
      );
    }
    
    // Handling different status codes and returning or throwing appropriate response
    if (status === 204 || status === 205) {
      return;
    }
    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }
      throw new RequestError(response.statusText, status, {
        response: {
          url,
          status,
          headers,
          data: void 0
        },
        request: requestOptions
      });
    }
    if (status === 304) {
      throw new RequestError("Not modified", status, {
        response: {
          url,
          status,
          headers,
          data: await getResponseData(response)
        },
        request: requestOptions
      });
    }
    if (status >= 400) {
      const data = await getResponseData(response);
      const error = new RequestError(toErrorMessage(data), status, {
        response: {
          url,
          status,
          headers,
          data
        },
        request: requestOptions
      });
      throw error;
    }
    // If status code is between 200 and 300 (excluding 204 and 205), then parse the response body
    // If parseSuccessResponseBody flag is true, then parse the response body as JSON
    // Otherwise, return the response body as it is
    return parseSuccessResponseBody ? await getResponseData(response) : response.body;
  }).then((data) => {
    // Returning a response object with status, url, headers, and data properties
    return {
      status,
      url,
      headers,
      data
    };
  }).catch((error) => {
    // If error is an instance of RequestError, then throw it
    // If error is an instance of AbortError, then throw it
    // Otherwise, throw a new RequestError with error message and status code 500
    if (error instanceof RequestError)
      throw error;
    else if (error.name === "AbortError")
      throw error;
    let message = error.message;
    if (error.name === "TypeError" && "cause" in error) {
      if (error.cause instanceof Error) {
        message = error.cause.message;
      } else if (typeof error.cause === "string") {
        message = error.cause;
      }
    }
    throw new RequestError(message, 500, {
      request: requestOptions
    });
  });
}

// A helper function to parse response body as JSON or text
async function getResponseData(response) {
  const contentType = response.headers.get("content
