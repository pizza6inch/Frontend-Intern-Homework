/*!
 * finalhandler
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict'

/**
 * Module dependencies.
 * This section declares the modules that this code depends on.
 * These modules are required to be installed and available in the Node.js environment.
 * @private
 */

var debug = require('debug')('finalhandler') // debugging utility
var encodeUrl = require('encodeurl') // utility for encoding URLs
var escapeHtml = require('escape-html') // utility for escaping HTML characters
var onFinished = require('on-finished') // utility for executing a callback when a response is finished
var parseUrl = require('parseurl') // utility for parsing URLs
var statuses = require('statuses') // module for getting HTTP status code messages
var unpipe = require('unpipe') // utility for unpiping streams from a request

/**
 * Module variables.
 * This section declares variables that are used within the module.
 * @private
 */

var DOUBLE_SPACE_REGEXP = /\x20{2}/g // regular expression for matching double spaces
var NEWLINE_REGEXP = /\n/g // regular expression for matching newlines

/* istanbul ignore next */
var defer = typeof setImmediate === 'function'
  ? setImmediate
  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)) } // utility for deferring a function call
var isFinished = onFinished.isFinished // utility for checking if a response is finished

/**
 * Create a minimal HTML document.
 * This function creates a minimal HTML document with the given message.
 * @param {string} message - the message to include in the HTML document
 * @private
 */

function createHtmlDocument (message) {
  var body = escapeHtml(message)
    .replace(NEWLINE_REGEXP, '<br>') // replace newlines with <br>
    .replace(DOUBLE_SPACE_REGEXP, ' &nbsp;') // replace double spaces with &nbsp;

  return '<!DOCTYPE html>\n' +
    '<html lang="en">\n' +
    '<head>\n' +
    '<meta charset="utf-8">\n' +
    '<title>Error</title>\n' +
    '</head>\n' +
    '<body>\n' +
    '<pre>' + body + '</pre>\n' +
    '</body>\n' +
    '</html>\n'
}

/**
 * Module exports.
 * This section exports the finalhandler function, which is the main function that is used by other modules.
 * @public
 */

module.exports = finalhandler

/**
 * Create a function to handle the final response.
 * This function creates a function that handles the final response for a request.
 * @param {Request} req - the request object
 * @param {Response} res - the response object
 * @param {Object} [options] - the options object
 * @return {Function} - the finalhandler function
 * @public
 */

function finalhandler (req, res, options) {
  var opts = options || {}

  // get environment
  var env = opts.env || process.env.NODE_ENV || 'development'

  // get error callback
  var onerror = opts.onerror

  return function (err) {
    var headers
    var msg
    var status

    // ignore 404 on in-flight response
    if (!err && headersSent(res)) {
      debug('cannot 404 after headers sent')
      return
    }

    // unhandled error
    if (err) {
      // respect status code from error
      status = getErrorStatusCode(err)

      if (status === undefined) {
        // fallback to status code on response
        status = getResponseStatusCode(res)
      } else {
        // respect headers from error
        headers = getErrorHeaders(err)
      }

      // get error message
      msg = getErrorMessage(err, status, env)
    } else {
      // not found
      status = 404
      msg = 'Cannot ' + req.method + ' ' + encodeUrl(getResourceName(req))
    }

    debug('default %s', status)

    // schedule onerror callback
    if (err && onerror) {
      defer(onerror, err, req, res)
    }

    // cannot actually respond
    if (headersSent(res)) {
      debug('cannot %d after headers sent', status)
      req.socket.destroy()
      return
    }

    // send response
    send(req, res, status, headers, msg)
  }
}

/**
 * Get headers from Error object.
 * This function gets headers from an Error object.
 * @param {Error} err - the Error object
 * @return {object} - the headers object
 * @private
 */

function getErrorHeaders (err) {
  if (!err.headers || typeof err.headers !== 'object') {
    return undefined
  }

  var headers = Object.create(null)
  var keys = Object.keys(err.headers)

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i]
    headers[key] = err.headers[key]
  }

  return headers
}

/**
 * Get message from Error object, fallback to status message.
 * This function gets the message from an Error object, and falls back to the status message if the Error object does not have a message.
 * @param {Error} err - the Error object
 * @param {number} status - the HTTP status code
 * @param {string} env - the Node.js environment
 * @return {string} - the message string
 * @private
 */

function getErrorMessage (err, status, env) {
  var msg

  if (env !== 'production') {
    // use err.stack, which typically includes err.message
    msg = err.stack

    // fallback to err.toString() when possible
    if (!msg && typeof err.toString === 'function') {
      msg = err.toString()
    }
  }
