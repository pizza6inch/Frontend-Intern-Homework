'use strict';

// Import required modules
const test = require('tape');
const v = require('es-value-fixtures');
const forEach = require('for-each');
const inspect = require('object-inspect');
const hasOwn = require('hasown');
const hasPropertyDescriptors = require('has-property-descriptors')();
const getOwnPropertyDescriptors = require('object.getownpropertydescriptors');
const ownKeys = require('reflect.ownkeys');

// Import the function to be tested
const defineDataProperty = require('../');

// Start the test suite
test('defineDataProperty', function (t) {
  // Test argument validation
  t.test('argument validation', function (st) {
    // Check if the function throws a TypeError when the input is not an object
    forEach(v.primitives, function (nonObject) {
      st['throws'](
        // @ts-expect-error
        function () { defineDataProperty(nonObject, 'key', 'value'); },
        TypeError,
        'throws on non-object input: ' + inspect(nonObject)
      );
    });

    // Check if the function throws a TypeError when the property key is not a string or a symbol
    forEach(v.nonPropertyKeys, function (nonPropertyKey) {
      st['throws'](
        // @ts-expect-error
        function () { defineDataProperty({}, nonPropertyKey, 'value'); },
        TypeError,
        'throws on non-PropertyKey input: ' + inspect(nonPropertyKey)
      );
    });

    // Check if the function throws a TypeError when the flags are not booleans
    forEach(v.nonBooleans, function (nonBoolean) {
      if (nonBoolean !== null) {
        st['throws'](
          // @ts-expect-error
          function () { defineDataProperty({}, 'key', 'value', nonBoolean); },
          TypeError,
          'throws on non-boolean nonEnumerable: ' + inspect(nonBoolean)
        );

        st['throws'](
          // @ts-expect-error
          function () { defineDataProperty({}, 'key', 'value', false, nonBoolean); },
          TypeError,
          'throws on non-boolean nonWritable: ' + inspect(nonBoolean)
        );

        st['throws'](
          // @ts-expect-error
          function () { defineDataProperty({}, 'key', 'value', false, false, nonBoolean); },
          TypeError,
          'throws on non-boolean nonConfigurable: ' + inspect(nonBoolean)
        );
      }
    });

    // End the sub-test
    st.end();
  });

  // Test defining a normal data property
  t.test('normal data property', function (st) {
    // Create an object with an existing property
    const obj = { existing: 'existing property' };
    st.ok(hasOwn(obj, 'existing'), 'has initial own property');
    st.equal(obj.existing, 'existing property', 'has expected initial value');

    // Define a new property on the object
    const res = defineDataProperty(obj, 'added', 'added property');
    st.equal(res, void undefined, 'returns `undefined`');
    st.ok(hasOwn(obj, 'added'), 'has expected own property');
    st.equal(obj.added, 'added property', 'has expected value');

    // Modify the value of an existing property
    defineDataProperty(obj, 'existing', 'new value');
    st.ok(hasOwn(obj, 'existing'), 'still has expected own property');
    st.equal(obj.existing, 'new value', 'has new expected value');

    // Define a property with explicit flags
    defineDataProperty(obj, 'explicit1', 'new value', false);
    st.ok(hasOwn(obj, 'explicit1'), 'has expected own property (explicit enumerable)');
    st.equal(obj.explicit1, 'new value', 'has new expected value (explicit enumerable)');

    defineDataProperty(obj, 'explicit2', 'new value', false, false);
    st.ok(hasOwn(obj, 'explicit2'), 'has expected own property (explicit writable)');
    st.equal(obj.explicit2, 'new value', 'has new expected value (explicit writable)');

    defineDataProperty(obj, 'explicit3', 'new value', false, false, false);
    st.ok(hasOwn(obj, 'explicit3'), 'has expected own property (explicit configurable)');
    st.equal(obj.explicit3, 'new value', 'has new expected value (explicit configurable)');

    // End the sub-test
    st.end();
  });

  // Test defining a data property in loose mode
  t.test('loose mode', { skip: !hasPropertyDescriptors }, function (st) {
    const obj = { existing: 'existing property' };

    // Define a new property with loose mode
    defineDataProperty(obj, 'added', 'added value 1', true, null, null, true);
    st.deepEqual(
      getOwnPropertyDescriptors(obj),
      {
        existing: {
          configurable: true,
          enumerable: true,
          value: 'existing property',
          writable: true
        },
        added: {
          configurable: true,
          enumerable: !hasPropertyDescriptors,
          value: 'added value 1',
          writable: true
        }
      },
      'in loose mode, obj still adds property 1'
    );
