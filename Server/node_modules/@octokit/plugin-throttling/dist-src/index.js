import BottleneckLight from "bottleneck/light";
import { Octokit } from "@octokit/core";
import { VERSION } from "./version";
import { wrapRequest } from "./wrap-request";
import triggersNotificationPaths from "./generated/triggers-notification-paths";
import { routeMatcher } from "./route-matcher";

// This regular expression is used to test if a route triggers a notification
const regex = routeMatcher(triggersNotificationPaths);
const triggersNotification = regex.test.bind(regex);

// This object will store groups of Bottleneck limiter instances
const groups = {};

// This function creates new Bottleneck limiter groups
const createGroups = function(Bottleneck, common) {
  // The 'global' group is used for general requests
  groups.global = new Bottleneck.Group({
    id: "octokit-global",
    maxConcurrent: 10,
    ...common
  });
  // The 'search' group is used for search requests
  groups.search = new Bottleneck.Group({
    id: "octokit-search",
    maxConcurrent: 1,
    minTime: 2e3,
    ...common
  });
  // The 'write' group is used for write requests
  groups.write = new Bottleneck.Group({
    id: "octokit-write",
    maxConcurrent: 1,
    minTime: 1e3,
    ...common
  });
  // The 'notifications' group is used for notifications requests
  groups.notifications = new Bottleneck.Group({
    id: "octokit-notifications",
    maxConcurrent: 1,
    minTime: 3e3,
    ...common
  });
};

// This function adds throttling to an Octokit instance
function throttling(octokit, octokitOptions) {
  const {
    enabled = true,
    Bottleneck = BottleneckLight,
    id = "no-id",
    timeout = 1e3 * 60 * 2,
    // Redis TTL: 2 minutes
    connection
  } = octokitOptions.throttle || {};

  // If throttling is not enabled, return an empty object
  if (!enabled) {
    return {};
  }

  const common = { connection, timeout };

  // If the 'groups' object is null, create new limiter groups
  if (groups.global == null) {
    createGroups(Bottleneck, common);
  }

  // This object stores the state of the throttling plugin
  const state = Object.assign(
    {
      clustering: connection != null,
      triggersNotification,
      fallbackSecondaryRateRetryAfter: 60,
      retryAfterBaseValue: 1e3,
      retryLimiter: new Bottleneck(),
      id,
      ...groups
    },
    octokitOptions.throttle
  );

  // These functions handle rate limit and secondary rate limit events
  if (typeof state.onSecondaryRateLimit !== "function" || typeof state.onRateLimit !== "function") {
    throw new Error(`octokit/plugin-throttling error:
        You must pass the onSecondaryRateLimit and onRateLimit error handlers.
        See https://octokit.github.io/rest.js/#throttling

        const octokit = new Octokit({
          throttle: {
            onSecondaryRateLimit: (retryAfter, options) => {/* ... */},
            onRateLimit: (retryAfter, options) => {/* ... */}
          }
        })
    `);
  }

  // This object stores event listeners for the Bottleneck limiter
  const events = {};

  // This is the event emitter for the Bottleneck limiter
  const emitter = new Bottleneck.Events(events);

  // These event listeners handle rate limit and secondary rate limit events
  events.on("secondary-limit", state.onSecondaryRateLimit);
  events.on("rate-limit", state.onRateLimit);
  events.on(
    "error",
    (e) => octokit.log.warn("Error in throttling-plugin limit handler", e)
  );

  // This is the retry limiter for the throttling plugin
  state.retryLimiter.on("failed", async function(error, info) {
    // ...
  });

  // This function wraps the 'request' hook of the Octokit instance
  octokit.hook.wrap("request", wrapRequest.bind(null, state));

  // Return an empty object
  return {};
}
throttling.VERSION = VERSION;
throttling.triggersNotification = triggersNotification;
export {
  throttling
};
