// The main ipaddr object, which serves as the base for IPv4 and IPv6 classes
const ipaddr = {
  // Exports the ipaddr object as a module
  [Symbol.toStringTag]: 'Module',
};

// The IPv4 class, which handles IPv4 addresses
class IPv4 {
  constructor(octets) {
    // Check if the input is a valid IPv4 address
    if (octets.length !== 4) {
      throw new Error('ipaddr: IPv4 octet count should be 4');
    }
    for (const octet of octets) {
      if (!((0 <= octet && octet <= 255))) {
        throw new Error('ipaddr: IPv4 octet should fit in 8 bits');
      }
    }
    this.octets = octets;
  }

  // Returns the address kind ('ipv4')
  kind() {
    return 'ipv4';
  }

  // Converts the address to a string (e.g., "192.168.1.1")
  toString() {
    return this.octets.join('.');
  }

  // Converts the address to a normalized string (e.g., "192.168.1.1")
  toNormalizedString() {
    return this.toString();
  }

  // Converts the address to a byte array (e.g., [192, 168, 1, 1])
  toByteArray() {
    return this.octets.slice(0);
  }

  // Matches the address with another IPv4 address and a CIDR range
  match(other, cidrRange) {
    // ...
  }

  // Special ranges for unspecified, broadcast, multicast, loopback, and other reserved IPv4 addresses
  get SpecialRanges() {
    return {
      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
      multicast: [[new IPv4([224, 0, 0, 0]), 4]],
      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
      loopback: [[new IPv4([127, 0, 0, 0]), 8]],
      carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
      private: [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]],
    };
  }

  // Returns the range of the address (e.g., 'unicast')
  range() {
    return ipaddr.subnetMatch(this, this.SpecialRanges);
  }

  // Converts the address to an IPv4-mapped IPv6 address
  toIPv4MappedAddress() {
    return ipaddr.IPv6.parse("::ffff:" + this.toString());
  }

  // Returns the prefix length from a subnet mask
  prefixLengthFromSubnetMask() {
    // ...
  }
}

// The IPv6 class, which handles IPv6 addresses
class IPv6 {
  constructor(parts, zoneId) {
    // Check if the input is a valid IPv6 address
    if (parts.length === 16) {
      this.parts = [];
      for (let i = 0; i <= 14; i += 2) {
        this.parts.push((parts[i] << 8) | parts[i + 1]);
      }
    } else if (parts.length === 8) {
      this.parts = parts;
    } else {
      throw new Error('ipaddr: IPv6 part count should be 8 or 16');
    }

    // Check if each part fits in 16 bits
    const ref = this.parts;
    for (let l = 0, len = ref.length; l < len; l++) {
      const part = ref[l];
      if (!
