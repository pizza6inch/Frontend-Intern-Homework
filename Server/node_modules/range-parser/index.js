/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict'

/**
 * Module exports.
 * @public
 */

module.exports = rangeParser // The module exports a single function, `rangeParser`.

/**
 * Parse "Range" header `str` relative to the given file `size`.
 *
 * @param {Number} size
 * @param {String} str
 * @param {Object} [options]
 * @return {Array}
 * @public
 */

function rangeParser (size, str, options) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string') // Validates the input string.
  }

  // Splits the range string into individual ranges.
  var index = str.indexOf('=')
  var arr = str.slice(index + 1).split(',')
  var ranges = []

  // Adds the ranges type to the `ranges` array.
  ranges.type = str.slice(0, index)

  // Parses all ranges.
  for (var i = 0; i < arr.length; i++) {
    // Splits each range into start and end positions.
    var range = arr[i].split('-')
    var start = parseInt(range[0], 10)
    var end = parseInt(range[1], 10)

    // Handles special cases where the start or end position is missing.
    if (isNaN(start)) {
      start = size - end
      end = size - 1
    } else if (isNaN(end)) {
      end = size - 1
    }

    // Limits the last-byte-pos to the current length.
    if (end > size - 1) {
      end = size - 1
    }

    // Validates the input and skips invalid ranges.
    if (isNaN(start) || isNaN(end) || start > end || start < 0) {
      continue
    }

    // Adds a range object to the `ranges` array.
    ranges.push({
      start: start,
      end: end
    })
  }

  // Returns the `ranges` array if it's empty or unsatisfiable.
  if (ranges.length < 1) {
    return -1
  }

  // Combines overlapping and adjacent ranges if the `options` object has a `combine` property set to `true`.
  return options && options.combine
    ? combineRanges(ranges)
    : ranges
}

/**
 * Combine overlapping & adjacent ranges.
 * @private
 */

// Combines overlapping and adjacent ranges in the `ranges` array.
function combineRanges (ranges) {
  // Adds an index property to each range object.
  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart)

  // Combines overlapping and adjacent ranges.
  for (var j = 0, i = 1; i < ordered.length; i++) {
    var range = ordered[i]
    var current = ordered[j]

    // Skips to the next range if the current range is not adjacent to the next range.
    if (range.start > current.end + 1) {
      ordered[++j] = range
      continue
    }

    // Extends the current range if the next range is a subset or a superset of the current range.
    if (range.end > current.end) {
      current.end = range.end
      current.index = Math.min(current.index, range.index)
    }
  }

  // Trims the `ordered` array.
  ordered.length = j + 1

  // Generates the combined range array.
 
