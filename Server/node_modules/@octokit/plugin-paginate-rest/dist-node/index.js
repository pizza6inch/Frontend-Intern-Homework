// Exports the main functions of the package
exports.composePaginateRest = Object.assign(paginate.bind(null, octokit), {
  iterator: iterator.bind(null, octokit)
});

// The version of the package
exports.VERSION = VERSION;

// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  composePaginateRest,
  isPaginatingEndpoint,
  paginateRest,
  paginatingEndpoints
});


// A function that normalizes the response of paginated API calls to ensure a consistent format
function normalizePaginatedListResponse(response) {
  if (!response.data) {
    return {
      ...response,
      data: []
    };
  }

  const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
  if (!responseNeedsNormalization)
    return response;

  const incompleteResults = response.data.incomplete_results;
  const repositorySelection = response.data.repository_selection;
  const totalCount = response.data.total_count;
  delete response.data.incomplete_results;
  delete response.data.repository_selection;
  delete response.data.total_count;

  const namespaceKey = Object.keys(response.data)[0];
  const data = response.data[namespaceKey];
  response.data = data;

  if (typeof incompleteResults !== "undefined") {
    response.data.incomplete_results = incompleteResults;
  }
  if (typeof repositorySelection !== "undefined") {
    response.data.repository_selection = repositorySelection;
  }
  response.data.total_count = totalCount;

  return response;
}

module.exports = normalizePaginatedListResponse;


// An async generator function that iterates over the pages of a paginated API response
async function* iterator(octokit, route, parameters) {
  const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
  const requestMethod = typeof route === "function" ? route : octokit.request;
  const method = options.method;
  const headers = options.headers;
  let url = options.url;

  while (url) {
    const response = await requestMethod({ method, url, headers });
    const normalizedResponse = normalizePaginatedListResponse(response);
    url = ((normalizedResponse.headers.link || "").match(
      /<([^>]+)>;\s*rel="next"/
    ) || [])[1];
    yield normalizedResponse;
  }
}

module.exports = iterator;


// A function that gathers the data from an API paginated response into a single array
async function paginate(octokit, route, parameters, mapFn) {
  if (typeof parameters === "function") {
    mapFn = parameters;
    parameters = void 0;
  }

  const iterator2 = iterator(octokit, route, parameters)[Symbol.asyncIterator]();
  let results = [];

  for await (const page of iterator2) {
    results = results.concat(mapFn ? mapFn(page) : page.data);
  }

  return results;
}

module.exports = paginate;


// Composes the `paginate` and `iterator` functions, and exports them as a single object
const composePaginateRest = Object.assign(paginate, {
  iterator
});

module.exports = composePaginateRest;


// A list of GitHub API endpoints that are known to return paginated responses
const paginatingEndpoints = [
  // ...
];

module.exports = paginatingEndpoints;


// A function that checks if a given string is in the list of known paginated endpoints
function isPaginatingEndpoint(arg) {
  if (typeof arg === "string") {
    return paginatingEndpoints.includes(arg);
  } else {
    return false;
  }
}

module.exports = isPaginatingEndpoint;


// The main export of the package, which provides a convenient way to use the pagination utilities
const paginateRest = (octokit) =>
