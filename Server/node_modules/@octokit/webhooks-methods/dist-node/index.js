"use strict";

// Import the 'crypto' module from Node.js to generate cryptographic hashes
const { createHmac } = require("node:crypto");

// Import the 'buffer' module from Node.js to work with binary data
const { Buffer } = require("node:buffer");

// Import the 'Algorithm' type from './types.js'
const { Algorithm } = require("./types");

// Import the 'getAlgorithm' utility function from './utils.js'
const { getAlgorithm } = require("./utils");

// Import the 'verify' function from './verify.js'
const { verify } = require("./verify");

// Export the 'sign', 'verify', and 'verifyWithFallback' functions
module.exports = {
  sign,
  verify,
  verifyWithFallback,
};

// The 'sign' function generates a signature for the given payload and secret
// using the specified algorithm.
async function sign(options, payload) {
  const { secret, algorithm } = typeof options === "object" ? {
    secret: options.secret,
    algorithm: options.algorithm || Algorithm.SHA256
  } : { secret, algorithm: Algorithm.SHA256 };

  // Throw an error if the secret or payload is not provided
  if (!secret || !payload) {
    throw new TypeError(
      "[@octokit/webhooks-methods] secret & payload required for sign()"
    );
  }

  // Throw an error if the payload is not a string
  if (typeof payload !== "string") {
    throw new TypeError("[@octokit/webhooks-methods] payload must be a string");
  }

  // Throw an error if the algorithm is not supported
  if (!Object.values(Algorithm).includes(algorithm)) {
    throw new TypeError(
      `[@octokit/webhooks] Algorithm ${algorithm} is not supported. Must be  'sha1' or 'sha256'`
    );
  }

  // Return the signature as a string in the format: algorithm=base64-encoded-signature
  return `${algorithm}=${createHmac(algorithm, secret)
    .update(payload)
    .digest("hex")}`;
}

// The 'sign' function version
sign.VERSION = VERSION;

// The 'verify' function checks if the given signature matches the signature
// generated for the given payload and secret using the specified algorithm.
async function verify(secret, eventPayload, signature) {
  // Throw an error if the secret, eventPayload, or signature is not provided
  if (!secret || !eventPayload || !signature) {
    throw new TypeError(
      "[@octokit/webhooks-methods] secret, eventPayload & signature required"
    );
  }

  // Throw an error if the eventPayload is not a string
  if (typeof eventPayload !== "string") {
    throw new TypeError(
      "[@octokit/webhooks-methods] eventPayload must be a string"
    );
  }

  // Convert the signature to a Buffer
  const signatureBuffer = Buffer.from(signature);

  // Determine the algorithm from the signature
  const algorithm = getAlgorithm(signature);

  // Generate the verification signature
  const verificationBuffer = Buffer.from(
    await sign({ secret, algorithm }, eventPayload)
  );

  // Compare the signature and the verification signature
  if (signatureBuffer.length !== verificationBuffer.length) {
    return false;
  }

  // Return true if the signatures match, false otherwise
  return Buffer.compare(signatureBuffer, verificationBuffer) === 0;
}

// The 'verify' function version
verify.VERSION = VERSION;

// The 'verifyWithFallback' function checks if the given signature matches the
// signature generated for the given payload and secret using the specified
// algorithm. If the signature does not match, the function checks the signature
// against a list of additional secrets.
async function verifyWithFallback(secret, payload, signature, additionalSecrets) {
  // Check the signature against the first secret
  const firstPass = await verify(secret, payload, signature);

  // Return true if the signature matches
  if (firstPass) {
    return true;
  }

  // Check the signature against the additional secrets
  if (additionalSecrets !== void 0) {
    for (const s of additionalSecrets) {
      // Return true if the signature matches
      const v = await verify(s, payload, signature);
      if (v) {
        return v;
      }
    }
  }

  // Return false if the signature does not match any of the secrets
  return false;
}

// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  sign,
  verify,
  verifyWithFallback
});
