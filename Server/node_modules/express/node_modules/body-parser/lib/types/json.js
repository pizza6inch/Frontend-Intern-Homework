/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict'

/**
 * Module dependencies.
 * @private
 */

// Import required modules: bytes, content-type, createError, debug, read, and type-is

/**
 * Module exports.
 */

// Export the json function as the default export
module.exports = json

/**
 * RegExp to match the first non-space in a string.
 *
 * Allowed whitespace is defined in RFC 7159:
 *
 *    ws = *(
 *            %x20 /              ; Space
 *            %x09 /              ; Horizontal tab
 *            %x0A /              ; Line feed or New line
 *            %x0D )              ; Carriage return
 */

// Define a regular expression to match the first non-space character in a string
var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/ // eslint-disable-line no-control-regex

/**
 * Create a middleware to parse JSON bodies.
 *
 * @param {object} [options]
 * @return {function}
 * @public
 */

// Define the json function with options parameter and return a function
function json (options) {
  // Destructure the options object
  var opts = options || {}

  // Define the limit variable based on the options.limit value
  var limit = typeof opts.limit !== 'number'
    ? bytes.parse(opts.limit || '100kb')
    : opts.limit
  // Define the inflate variable based on the options.inflate value
  var inflate = opts.inflate !== false
  // Define the reviver variable based on the options.reviver value
  var reviver = opts.reviver
  // Define the strict variable based on the options.strict value
  var strict = opts.strict !== false
  // Define the type variable based on the options.type value
  var type = opts.type || 'application/json'
  // Define the verify variable based on the options.verify value
  var verify = opts.verify || false

  // Validate the verify option
  if (verify !== false && typeof verify !== 'function') {
    throw new TypeError('option verify must be function')
  }

  // Define the shouldParse function based on the type variable
  // If the type variable is not a function, use the typeChecker function to create a type checker
  var shouldParse = typeof type !== 'function'
    ? typeChecker(type)
    : type

  // Define the parse function
  function parse (body) {
    // Check if the body is empty and return an empty object if it is
    if (body.length === 0) {
      return {}
    }

    // Check if the strict mode is enabled and if the first character of the body is not { or [
    if (strict) {
      var first = firstchar(body)

      if (first !== '{' && first !== '[') {
        debug('strict violation')
        // Throw a syntax error if the body does not start with { or [
        throw createStrictSyntaxError(body, first)
      }
    }

    // Parse the body as JSON and return the result
    try {
      debug('parse json')
      return JSON.parse(body, reviver)
    } catch (e) {
      // Normalize the syntax error and rethrow it
      throw normalizeJsonSyntaxError(e, {
        message: e.message,
        stack: e.stack
      })
    }
  }

  // Define the jsonParser function
  return function jsonParser (req, res, next) {
    // Check if the body has already been parsed
    if (req._body) {
      debug('body already parsed')
      // Skip the parsing if the body has already been parsed
      next()
      return
    }

    // Define the req.body object
    req.body = req.body || {}

    // Check if the request has a body
    // Skip the parsing if the request does not have a body
    if (!typeis.hasBody(req)) {
      debug('skip empty body')
      next()
      return
    }

    // Log the content-type header of the request
    debug('content-type %j', req.headers['content-type'])

    // Check if the request should be parsed
    // Skip the parsing if the request should not be parsed
    if (!shouldParse(req)) {
      debug('skip parsing')
      next()
      return
    }

    // Assert the charset of the request
    // Throw an error if the charset is not utf-8
    var charset = getCharset(req) || 'utf-8'
    if (charset.slice(0, 4) !== 'utf-') {
      debug('invalid charset')
      next(createError(415, 'unsupported charset "' + charset.toUpperCase() + '"', {
        charset: charset,
        type: 'charset.unsupported'
      }))
      return
    }

    // Read the request body and parse it as JSON
    read(req, res, next, parse, debug, {
      encoding: charset,
      inflate: inflate,
      limit: limit,
      verify: verify
    })
  }
}

/**
 * Create strict violation syntax error matching native error.
 *
 * @param {string} str
 * @param {string} char
 * @return {Error}
 * @private
 */

// Define the createStrictSyntaxError function
// Create a syntax error that matches the native error
function createStrictSyntaxError (str, char) {
  var index = str.indexOf(char)
  var partial = index !== -1
    // Create a partial string with the first non-whitespace character replaced with #
    ? str.substring(0, index) + '#'
    : ''

  // Try to parse the partial string as JSON and throw a syntax error
 
